

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-92365403-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Layers in IoT &#8212; tech.bitvijays.com</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html">tech.bitvijays.com</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Layers in IoT</a></li>
<li><a class="reference internal" href="#iot-pentest">IoT Pentest</a><ul>
<li><a class="reference internal" href="#attack-surface-mapping">Attack Surface Mapping</a><ul>
<li><a class="reference internal" href="#embedded-devices-vulns">Embedded Devices Vulns</a></li>
<li><a class="reference internal" href="#firmware-software-and-applications">Firmware, Software and Applications</a></li>
<li><a class="reference internal" href="#radio-communications">Radio Communications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analyzing-hardware">Analyzing Hardware</a><ul>
<li><a class="reference internal" href="#visual-inspection">Visual Inspection</a></li>
<li><a class="reference internal" href="#component-package">Component Package</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uart-communication">UART Communication</a><ul>
<li><a class="reference internal" href="#uart-data-packet">UART Data Packet</a></li>
<li><a class="reference internal" href="#type-of-uart-ports">Type of UART Ports</a></li>
<li><a class="reference internal" href="#baud-rate">Baud Rate</a></li>
<li><a class="reference internal" href="#connections-for-uart-exploitation">Connections for UART Exploitation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#exploitation-using-i2c-and-spi">Exploitation using I2C and SPI</a><ul>
<li><a class="reference internal" href="#i2c-inter-intergrate-circuit">I2C (Inter-Intergrate Circuit)</a><ul>
<li><a class="reference internal" href="#understading-eeprom">Understading EEPROM</a></li>
<li><a class="reference internal" href="#exploiting-i2c-security">Exploiting I2C Security</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summarize">Summarize</a></li>
<li><a class="reference internal" href="#spi">SPI</a><ul>
<li><a class="reference internal" href="#how-does-spi-work">How does SPI work?</a></li>
<li><a class="reference internal" href="#reading-and-writing-from-spi-eeprom">Reading and Writing from SPI EEPROM</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#jtag">JTAG</a><ul>
<li><a class="reference internal" href="#boundary-scan">Boundary Scan</a></li>
<li><a class="reference internal" href="#test-access-port">Test Access Port</a><ul>
<li><a class="reference internal" href="#boundary-scan-instructions">Boundary Scan Instructions</a></li>
<li><a class="reference internal" href="#test-process">Test process</a></li>
<li><a class="reference internal" href="#debugging-with-jtag">Debugging with JTAG</a></li>
<li><a class="reference internal" href="#identifying-jtag-pinouts">Identifying JTAG pinouts</a></li>
<li><a class="reference internal" href="#what-is-openocd">What is OpenOCD</a></li>
<li><a class="reference internal" href="#installing-software-for-jtag-debugging">Installing software for JTAG debugging</a></li>
<li><a class="reference internal" href="#debugging-over-jtag-with-gdb">Debugging over JTAG with GDB</a></li>
</ul>
</li>
<li><a class="reference internal" href="#firmware-reverse-engineering-and-exploitation">Firmware Reverse Engineering and Exploitation</a></li>
<li><a class="reference internal" href="#how-to-get-firmware-binary">How to get Firmware Binary</a></li>
<li><a class="reference internal" href="#firmware-internals">Firmware Internals</a><ul>
<li><a class="reference internal" href="#hardcoded-secrets">Hardcoded Secrets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#encrypted-firmware">Encrypted Firmware?</a><ul>
<li><a class="reference internal" href="#emulating-a-firmware-binary">Emulating a Firmware Binary</a></li>
<li><a class="reference internal" href="#backdooring-a-firmware">Backdooring a Firmware</a></li>
<li><a class="reference internal" href="#running-automated-firmware-scanning-tools">Running Automated firmware scanning tools</a></li>
<li><a class="reference internal" href="#firmware-diffing">Firmware Diffing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#software-defined-radio">Software Defined Radio</a><ul>
<li><a class="reference internal" href="#setting-up-the-lab">Setting up the lab</a></li>
<li><a class="reference internal" href="#hackrf">HackRF</a></li>
</ul>
</li>
<li><a class="reference internal" href="#zigbee">ZigBee</a><ul>
<li><a class="reference internal" href="#understading-zigbee-communication">Understading ZigBee Communication</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ble">BLE</a><ul>
<li><a class="reference internal" href="#hardware">Hardware</a></li>
<li><a class="reference internal" href="#sniffing-ble-packets">Sniffing BLE Packets</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/LFF-IoT.rst.txt"
           rel="nofollow">Show Source</a></li>
    <li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/blob/master/docs/LFF-IoT.rst"
           rel="nofollow">Show on GitHub</a></li>
    <li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/edit/master/docs/LFF-IoT.rst"
           rel="nofollow">Edit on GitHub</a></li>
  </ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>###This is NOT Completed!</p>
<div class="section" id="layers-in-iot">
<h1>Layers in IoT<a class="headerlink" href="#layers-in-iot" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>Controlling Device</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Insecure network communication</li>
<li>Insecure authentication and authorization</li>
<li>Business and Logical Flaws</li>
<li>Hardcoded sensitive information</li>
<li>Outdated and/ or insecure 3rd party libraries and SDKs</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Cloud Service (IoT Platform)</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Insecure API communication</li>
<li>Improper protection against sensitive resources</li>
<li>Ability to modify sensitive data</li>
<li>Side channel data leakage</li>
<li>Injection based attacks</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Global network and Local network (Gateway Platforms?)</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Man in the middle attack</li>
<li>Replay based attacks</li>
<li>Jamming attacks</li>
<li>Sensitive data in clear text</li>
<li>Insecure encryption and authentication</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Things (Devices)</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Exposed serial interfaces</li>
<li>Ability to dump sensitive information and firmware from the flash chips</li>
<li>Insecure integrity and signature verification</li>
<li>Insecure OTA update mechanism</li>
<li>External media attack vectors</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="iot-pentest">
<h1>IoT Pentest<a class="headerlink" href="#iot-pentest" title="Permalink to this headline">¶</a></h1>
<div class="section" id="attack-surface-mapping">
<h2>Attack Surface Mapping<a class="headerlink" href="#attack-surface-mapping" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Understand the architecture of the IoT solution.</li>
<li>Read documentation of the device, online resources.</li>
<li>Note down various components used in device, communication protocols, mobile application details, firmware upgrade process, hardware ports, external media support on devices.</li>
</ul>
<p>IoT Architecture can be divided into three categories</p>
<ul class="simple">
<li>Embedded Device</li>
<li>Firmware, Software, and Applications</li>
<li>Radio Communications</li>
</ul>
<div class="section" id="embedded-devices-vulns">
<h3>Embedded Devices Vulns<a class="headerlink" href="#embedded-devices-vulns" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Serial ports exposed</li>
<li>Insecure authentication mechanism used in serial ports</li>
<li>Ability to dump the firmware over JTAG or via Flash Chips</li>
<li>External media based attacks</li>
<li>Power analysis and Side Channel based attacks</li>
</ul>
</div>
<div class="section" id="firmware-software-and-applications">
<h3>Firmware, Software and Applications<a class="headerlink" href="#firmware-software-and-applications" title="Permalink to this headline">¶</a></h3>
<p>Firmware</p>
<ul class="simple">
<li>Ability to modify firmware</li>
<li>Insecure signature and integrity verification</li>
<li>Hardcoded sensitive values in firmware - API keys, passwords, staging URLs etc.</li>
<li>Private certificates</li>
<li>Ability to understand the entire functionality of the device through the firmware.</li>
<li>File system extraction from the firmware</li>
<li>Outdated components with known vulnerabilities</li>
</ul>
<p>Mobile Application
* Reverse engineering the mobile app
* Dumping source code of the mobile application
* Insecure authentication and authorization checks
* Business and logic flaws
* Side channel data leakage
* Runtime manipulation attacks
* Insecure network communication
* Outdated 3rd party libraries and SDKs</p>
<p>Web Application
* OWASP Top 10.</p>
</div>
<div class="section" id="radio-communications">
<h3>Radio Communications<a class="headerlink" href="#radio-communications" title="Permalink to this headline">¶</a></h3>
<p>Major categories in radio communication</p>
<ul class="simple">
<li>Software Defined Radio (SDR)</li>
<li>ZigBee exploitation</li>
<li>BLE (Bluetooth Low Energy) Exploitation</li>
</ul>
<p>Vulns</p>
<ul class="simple">
<li>Man in the middle attack</li>
<li>Replay based attacks</li>
<li>Insecure CRC verification</li>
<li>Jamming based attacks</li>
<li>Denial of Service</li>
<li>Lack of Encryption</li>
<li>Ability to extract sensitive information from radio packets</li>
<li>Live radio communication interception and modification.</li>
</ul>
<p>Stuff to keep in mind while creating an Attack Surface Map for radio communication</p>
<ul class="simple">
<li>What are the roles of various components involved?</li>
<li>Which component initiates authentication and pairing mechanism?</li>
<li>How many devices can each component handle simultaneously?</li>
<li>Which frequency does the device operate on?</li>
<li>What protocols are being used by different components? Is it custom or preprietary protocol?</li>
<li>Are there any similar devices operating on around the same frequency range as this devices?</li>
</ul>
<p>Creating Attack Surface Map</p>
<ul class="simple">
<li>Prepare an architecture diagram</li>
<li>Label components and communication between them.</li>
<li>Identify attack vectors for each component and the communication channel/ protocol used</li>
<li>Categorize the attack vectors based on the varying criticality.</li>
</ul>
<p>Frequency of the device can be found from fccid.io where we can enter FCC ID of an IoT device and find information about it.</p>
<p>FCC stands for Federal Communication Commission, a general body to regulate various devices emitting radio communications.</p>
</div>
</div>
<div class="section" id="analyzing-hardware">
<h2>Analyzing Hardware<a class="headerlink" href="#analyzing-hardware" title="Permalink to this headline">¶</a></h2>
<div class="section" id="visual-inspection">
<h3>Visual Inspection<a class="headerlink" href="#visual-inspection" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>What are how many buttons are present?</li>
<li>External interfacing options - Ethernet port, SD Card slot, etc.</li>
<li>What kind of display does the device has?</li>
<li>Power and voltage requirements for the device.</li>
<li>Does the device carry any certifications - If Yes, what do they mean?</li>
<li>Does the device has any FCC ID labels on the back?</li>
<li>Does the device look like any other devices with similar functionalities (that you have seen in market)(maybe it’s just a rebranded model of the same).</li>
</ul>
<p>www.datasheets360.com or www.alldatasheet.com might provide good datasheets.</p>
<p>Debug Ports and Interfaces? – we can communicate with the device using UART and JTAG.</p>
</div>
<div class="section" id="component-package">
<h3>Component Package<a class="headerlink" href="#component-package" title="Permalink to this headline">¶</a></h3>
<p>Packaging Type/ Options. Based on what packaging a component is using, for analysis, we would require corresponding hardware adapters and other components to interact with them.</p>
<p>Most commonly used packaging is below</p>
<ul class="simple">
<li>DIL</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Single in-line package</li>
<li>Dual in-line package</li>
<li>TO-220</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>SMD</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>CERPACK</li>
<li>BGA</li>
<li>SOT-23</li>
<li>QFP</li>
<li>SOIC</li>
<li>SOP</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="uart-communication">
<h2>UART Communication<a class="headerlink" href="#uart-communication" title="Permalink to this headline">¶</a></h2>
<p>Universal Asynchronous Receiver/ Transmitter is a way of serial communication allowing two different components on a device to talk to each other without the requirement of a clock.</p>
<p>From a security standpoint, the ability to interact with UART will be useful to read device debug logs, get unauthenticated root shell, bootloader access.</p>
<p>Serial communication is used to transfer one bit at a time through a given medium. Examples RS232, USB, PCI, HDMI, Ethernet, SPI, I2C, CAN.</p>
<div class="section" id="uart-data-packet">
<h3>UART Data Packet<a class="headerlink" href="#uart-data-packet" title="Permalink to this headline">¶</a></h3>
<p>UART data packet consists of</p>
<ul class="simple">
<li>Starting Bit: Symbolizes that the UART data is going to be followed next. Usually a low pulse (0).</li>
<li>Message : Actual message that is to be transferred as an 8-bit format.</li>
<li>Parity bit : is used to perform error and data corruption checking by counting the number of high or low values in the message, and based on whether it’s an odd parity or an even parity, it would tell that the data is not correct.</li>
<li>Stop bit: Final bit which symbolizes that the message has now completed. Usually done by a high pulse (1).</li>
</ul>
<p>Devices may have configuration of 8N1 - means 8 data bits, no parity bits and 1 stop bit. We may connect a Logic Analyzer to device’s UART interfaces.</p>
<p>A logic analyzer is a device which helps display various signals and logic levels from a digital circuit. Saleae Logic Analyzer or Open Workbench Logic Sniffer is a good logic analyzer.</p>
</div>
<div class="section" id="type-of-uart-ports">
<h3>Type of UART Ports<a class="headerlink" href="#type-of-uart-ports" title="Permalink to this headline">¶</a></h3>
<p>UART port could either be hardware or software based. Atmel microcontrollers - AT89S52 or ATMEGA328 has one hardware serial port and a user can emulate more software UART ports on specific GPIOs (General Purpose Input Output). Software based UART
may be required to connect multiple devices via UART to a given device.</p>
<p>UART, JTAG, SPI, I2C are mainly present either to provide additional functionality to the developer or facilitate component to component communication.</p>
</div>
<div class="section" id="baud-rate">
<h3>Baud Rate<a class="headerlink" href="#baud-rate" title="Permalink to this headline">¶</a></h3>
<p>Baud rate specifies the rate at which data is transferred between devices, or the number of bits per second that are being transferred. As there is no clock line, both the devices need to have mutual understanding of speed of data communication.</p>
<p>Security research first step is to identify the baud rate of the target device. The common baud rates are 9600, 38400, 19200, 57600 and 115200. We can use a script written by Craig Heffner <a href="#id1"><span class="problematic" id="id2">`baudrate.py &lt;https://github.com/devttys0/baudrate/blob/master/baudrate.py`_</span></a>
which allows us to change baud rates while maintaining a serial connection, to identify what is the correct value of the baud rate by looking at the output and visually inspecting for readable output.</p>
</div>
<div class="section" id="connections-for-uart-exploitation">
<h3>Connections for UART Exploitation<a class="headerlink" href="#connections-for-uart-exploitation" title="Permalink to this headline">¶</a></h3>
<p>To perform UART based exploitation, we need two primary components - target device and a device which could emulate a serial connection to access the end device.</p>
<p>Identifying UART ports can be done visually by looking for 3 or 4 pins close to each other.</p>
<p>UART consists of four pins</p>
<ul class="simple">
<li>Transmit (Tx) : Transmits data from the device to the other end.</li>
<li>Receive (Rx) : Receives data from the other end to the device</li>
<li>Ground (GND) : Ground reference pin</li>
<li>Voltage (Vcc) : Voltage, usually 3.3V or 5V.</li>
</ul>
<p>We can use multi-meter/ logic analyzer to identify the pins based on either the continuity test (for GND) or by looking at the voltage difference (for the remaining three pins).</p>
<ul class="simple">
<li>Ground will constant low voltage?</li>
<li>Vcc would have constant high voltage</li>
<li>Tx pin would have high/ low voltage during the bootup process because of the initial data transfer.</li>
<li>Rx might have low voltage during start-up.</li>
</ul>
<p>Either screen or minicom can be used to connect with the device after finding the baud rate.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>screen /dev/ttyUSB0 (COM port used by the connector) (baudrate).
</pre></div>
</div>
<p>Things to remember</p>
<ul class="simple">
<li>Connections are correct. e.g. Tx from one device goes to the Rx of other and Rx of other device goes to the Tx.</li>
<li>GND is connected to other device’s Ground.</li>
<li>Vcc is not connected to anything.</li>
<li>Baudrate is correctly identified.</li>
</ul>
<p>Once, we have access to the UART, interaction with bootloader, modification of certain values and dumping of firmware over UART is possible.</p>
</div>
</div>
</div>
<div class="section" id="exploitation-using-i2c-and-spi">
<h1>Exploitation using I2C and SPI<a class="headerlink" href="#exploitation-using-i2c-and-spi" title="Permalink to this headline">¶</a></h1>
<p>Both SPI and I2C are useful bus protocols used for data communication between different components in an Embedded device circuit. We can SPI and I2C exploitation techniques to dump contents (including firmware and other sensitive secrets)
from a device’s flash chip, or write content (such as malicious firmware image) to the flash chip.</p>
<div class="section" id="i2c-inter-intergrate-circuit">
<h2>I2C (Inter-Intergrate Circuit)<a class="headerlink" href="#i2c-inter-intergrate-circuit" title="Permalink to this headline">¶</a></h2>
<p>I2C is a multi-master protocol with only two wires being required to enable data exchange - Serial Data (SDA) and Serial Clock (SCL). I2C is only half-duplex which means it can only send or receive data at a given point of time.
I2C and SPI are meant for communicating with other peripherals located on the same circuit board. The SDA is for the data exchange, whereas the SCL (Clock line) is controlled by master and determines the speed at which the data exchange takes place.
The master also holds the address and memory location of all the various slaves devices which are used during any communication.</p>
<p>In I2C, there can be multiple masters, interacting with various slaves. That configuration is called a multi-master mode. Imagine what would happen if two masters wanted to take control over I2C bus at the same time, So, whichever master
pulls the SDA to LOW(0) first will gain the control of the bus.</p>
<p>SPI has faster data transmission rates compared to I2C, however it requires 3 pins for data transfer and one pin for Chip/ Slave select.</p>
<div class="section" id="understading-eeprom">
<h3>Understading EEPROM<a class="headerlink" href="#understading-eeprom" title="Permalink to this headline">¶</a></h3>
<p>EEPROM stands for Electrically Erasable Programmable Read Only Memory. Serial EEPROMs typically have 8 pins:</p>
<ul class="simple">
<li>Pin Name - Function</li>
</ul>
<ul class="simple">
<li>#CS - Chip Select</li>
<li>SCK - Serial Data Clock</li>
<li>MISO - Serial Data Input</li>
<li>MOSI - Serial Data Output</li>
<li>GND - Ground</li>
<li>VCC Power Supply</li>
<li>#WP - Write Protect</li>
<li>#HOLD Suspends Serial Input</li>
</ul>
<p>Chip Select : Both SPI and I2C (and other protocols) usually have multiple slaves, it is required to select one slave amongst others for any given action. Chip Select an EEPROM when the #CS is low. When a device is not selected, there will
be no communication happening between the master and the slave and the Serial Data Output pin remains in a high impedence state.</p>
<p>Clock: The clock or SCK determines the speed with which data exchange and communication take place. In case of I2C, the slaves can modify and slow down thte clock in case the clock speed selected by master is too fast for the slaves. Process is known as Clock Streching.</p>
<p>MISO/ MOSI : Master-In-Slave-Out and Master-Out-Slave-In. In case of I2C, (half-duplex), it can either read or write data at a given point of time. In case of SPI, both read and write data happends at the same time.</p>
<p>Write Protect - Pin allows normal read/ write operations when it is HIGH. When #WP is active LOW, all write operations are inhibited.</p>
<p>HOLD: When a device is selected and a serial sequence is underwayone slave amongst others for any given action. Chip Select an EEPROM when the #CS is low. When a device is not selected, there will
be no communication happening between the master and the slave and the Serial Data Output pin remains in a high impedence state.</p>
</div>
<div class="section" id="exploiting-i2c-security">
<h3>Exploiting I2C Security<a class="headerlink" href="#exploiting-i2c-security" title="Permalink to this headline">¶</a></h3>
<p>By exploiting I2C, we mean reading or writing data of the devices using an I2C EEPROM.</p>
<p>Basically, here read the datasheet of the component, of which we want to read the data, check the PINs connections.</p>
<p>To work with I2C, we can use <a href="#id3"><span class="problematic" id="id4">`i2ceeprom.py &lt;https://github.com/devttys0/libmpsse/blob/master/src/examples/i2ceeprom.py`_</span></a> by Craig Heffner.</p>
<p>Stuff such as Size of EEPROM chip, speed to be used might needs to be changed, so read and understand the script.</p>
</div>
</div>
<div class="section" id="summarize">
<h2>Summarize<a class="headerlink" href="#summarize" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Open the device</li>
<li>Identify the I2C chip on the PCB</li>
<li>Note the component number printed on I2C chip</li>
<li>Look up online for the datasheet to figure out the pinouts</li>
<li>Make the required connections</li>
<li>Use the i2ceeprom.py script to read or write data to the I2C EEPROM.</li>
</ul>
</div>
<div class="section" id="spi">
<h2>SPI<a class="headerlink" href="#spi" title="Permalink to this headline">¶</a></h2>
<p>SPI or Serial Peripheral Interface is full-duplex and consists of 3 wires - SCK, MOSI, MISO and additional chip select/ slave select. SPI is pretty loosely defined and different manufactures can modify the implementatiion in their own way,
To understand communication for any given chip on the target device, the best way is to lookup the datasheet and analyse how our target has implemented the SPI protocol for communication.</p>
<div class="section" id="how-does-spi-work">
<h3>How does SPI work?<a class="headerlink" href="#how-does-spi-work" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Master first configures the clock frequency according to the slave device clock frequency - typically up to a few MHz.</li>
<li>Fastest clock speed in SPI is half the speed of the master clock.</li>
<li>To start communication, the master selects the slave device with a logic level 0 on the SS line. Remember for every clock cycle, a full-duplex data transmission occurs.</li>
<li>The master initiates the communication by sending a bit on the MOSI line, which is read by the slave, whereas the slave sends a bit on the MISO line which is read by the master.</li>
<li>The most significatnt bit (MSB) is shifted first while a new least significant bit (LSB) is shifted into the same register. Once the register bit has been shifted out and in, the master and slave have successfully exchanged the register value.</li>
</ul>
</div>
<div class="section" id="reading-and-writing-from-spi-eeprom">
<h3>Reading and Writing from SPI EEPROM<a class="headerlink" href="#reading-and-writing-from-spi-eeprom" title="Permalink to this headline">¶</a></h3>
<p>To read and write data from/ to an SPI EEPROM, we can use <a href="#id5"><span class="problematic" id="id6">`spiflash.py &lt;https://github.com/devttys0/libmpsse`_</span></a></p>
</div>
</div>
</div>
<div class="section" id="jtag">
<h1>JTAG<a class="headerlink" href="#jtag" title="Permalink to this headline">¶</a></h1>
<p>JTAG is not a standard or protocol but rather a way of testing different chips present on the device and debugging them. JTAG uses a technique known as Boundary Scan which enables the manufactures to test and diagose the assembled PCBs.</p>
<div class="section" id="boundary-scan">
<h2>Boundary Scan<a class="headerlink" href="#boundary-scan" title="Permalink to this headline">¶</a></h2>
<p>Boundary Scan is a technique to debug and test various pins of the different chips present in a circuit. This is done by adding a piece of component call Boundary Scan Cells near each pin of the chip which needs to be tested.
The various I/O pins of the device are connected serially to form a chain. This chain could then be accessed by Test Access Port (TAP).</p>
<p>The Boundary Scan happens by sending data into one of the chips and matching the output to the input to verify if everything is functioning properly. An external file known as Boundary Scan description language file defines the
capabilities of any single device’s Boundary Scan logic.</p>
</div>
<div class="section" id="test-access-port">
<h2>Test Access Port<a class="headerlink" href="#test-access-port" title="Permalink to this headline">¶</a></h2>
<p>Test Access Point is a collective name given to the JTAG interfaces present on a device. There are five signals which TAP uses which control a state machine</p>
<ul class="simple">
<li>Test Clock (TCK) - used to synchronize the internal state machine operation and to clock serial data into the various boundary cells.</li>
<li>Test Data In (TDI) - The Serial Input Data pin to the Scan cells.</li>
<li>Test Data Out (TDO) - sends the serial output data from the Scan cells.</li>
<li>Test Mode Select (TMS) - used to control the state of the TAP controller.</li>
<li>Test Reset (TRST, optional) - the reset pin which is active low. When it is driven low, it will reset the internal state machine.</li>
</ul>
<p>The TCK, TMS, TRST pins drive a 16-bit TAP controller machine which manages the overall exchange of data and instructions.</p>
<p>The TAP controller is a 16-stage FSM (Finite State Machine) that proceeds from state to state, based on TMS and TCK signal. The TAP controller controls the test data register and the instruction register with the control signals.
If an instruction is to be sent, then the clock (TCK) is activated and the reset is set to active-low for the clock cycle. Once that is done, the reset signal is then deactivaed and the TMS is toggled to traverse the state machine for
further operation.</p>
<div class="section" id="boundary-scan-instructions">
<h3>Boundary Scan Instructions<a class="headerlink" href="#boundary-scan-instructions" title="Permalink to this headline">¶</a></h3>
<p>Set of instructions defined by IEEE 149.1 standard which must be made availalbe for a device in case of Boundary Scan</p>
<ul class="simple">
<li>Bypass : BYPASS instruction places the BYPASS register in the DR chain, so that the path from TDI and TDO involves only a single flip-flop (Shift-Resistor). This allows a specific chip to be tested in a serial chain without any overhead or
or interference from other chis.</li>
<li>SAMPLE/ PRELOAD: The SAMPLE/PRELOAD instruction places the Boundary Scan register in the DR chain. This instruction is used to preload the test data into the BSR. It is also used to copy the chip’s I/O value into the data register which can
then be moved out in successive shift-DR states.</li>
<li>EXTEST: The EXTEST instruction allows the user to test the off-chip circuitry. It is like the sample/ preload but also drives the value from the data register onto output pads.</li>
</ul>
</div>
<div class="section" id="test-process">
<h3>Test process<a class="headerlink" href="#test-process" title="Permalink to this headline">¶</a></h3>
<p>Below is the overall test process would like for a Boundary Scan process:</p>
<ul class="simple">
<li>The TAP controller applies test data on the TDI pins.</li>
<li>The BSR (Boundary Scan Register) monitors the input to the device and the data is captured by Boundary Scan cell.</li>
<li>The Data then goes in the device through the TDI pins.</li>
<li>The Data comes out of the device through the TDO pins.</li>
<li>The tester can verify the data on the output pin of the device and confirm if everything is working fine.</li>
</ul>
<p>These tests can be used to find things ranging from a simple manufacturing defect, to missing components in a board, to unconnected pins or incorrect placement of the device, and even device failures conditions.</p>
</div>
<div class="section" id="debugging-with-jtag">
<h3>Debugging with JTAG<a class="headerlink" href="#debugging-with-jtag" title="Permalink to this headline">¶</a></h3>
<p>As a pentester with access to JTAG, we would be able to
* dump the contents from the flash chip via JTAG.
* set breakpoints and analyse the entire stack, instruction sets and registers while debugging with JTAG and integrating it with a debugger.</p>
</div>
<div class="section" id="identifying-jtag-pinouts">
<h3>Identifying JTAG pinouts<a class="headerlink" href="#identifying-jtag-pinouts" title="Permalink to this headline">¶</a></h3>
<p>We would use additional tools JTAGulator to effectively determine the individual pinouts present in our target device. Another important thins is in most of the devices, we will find the JTAG pads, instead of
JTAG pins or pads with holes, which makes it important to have a bit of soldering experience.</p>
<p>In JTAG, we have four pins</p>
<ul class="simple">
<li>TDI</li>
<li>TDO</li>
<li>TMS</li>
<li>TCK</li>
</ul>
<p>We can identify JTAG pinouts using two approaches which differ based on hardware used</p>
<ul class="simple">
<li>Using JTAGulator</li>
<li>Using Ardunio flashed with JTAGEnum</li>
</ul>
<p>Using JTAGulator</p>
<ul class="simple">
<li>Open source hardware which helps us identify JTAG pinouts for a given target device. It has 24 I/O channels which can be used for pinout discovery and can also be used to detect UART pinouts.</li>
<li>It uses a FT232RL chip which allows it to handle entire USB protocol on a single chip and enables us to plug in the device and have it appear as a virtual serial port with which we can then interact using screen.</li>
</ul>
<p>To use JTAGulator, we need to connect all the various pins on our target device to the  JTAGulator channels, while connecting the ground to ground. Once done, we simply need to connect the JTAGulator to our system and run
screen with</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>screen /dev/ttyUSB0 115200
</pre></div>
</div>
<ul class="simple">
<li>Once, we are in the JTAGulator screen, the next step would be to set the target system voltage by hitting V to select the target voltage.</li>
<li>After selecting the voltage, the next step is to select a BYPASS scan to find out the pinouts. On selecting this, you wil lbe required to specify how many channels you have selected for the pinouts.</li>
<li>Once we have selected everything, JTAGulator will detect the various JTAGs pinouts.</li>
</ul>
<p>Using Ardunio flashed with JTAGEnum</p>
<p>To use JTAGEnum with Ardunio, download the code from <a href="#id7"><span class="problematic" id="id8">`JTAGEnum &lt;https://github.com/cyphunk/JTAGenum`_</span></a></p>
<p>This is a cheaper option, however extremely slow and not having the ability to detect the UART pinouts like JTAGulator does.</p>
<ul class="simple">
<li>Copy the code sample, open the Ardunio IDE and paste the code into the editor window. Select the correct port and Ardunio type from the menus options and Upload the code.</li>
<li>Interface with Ardunio via serial connection.</li>
</ul>
<p><em>Incomplete</em></p>
</div>
<div class="section" id="what-is-openocd">
<h3>What is OpenOCD<a class="headerlink" href="#what-is-openocd" title="Permalink to this headline">¶</a></h3>
<p>OpenOCD is a utility which allows us to perform On Chip Debugging with our target device via JTAG. Opensource software that interfaces with a hardware debugger’s JTAG port. Some of the things we can do</p>
<ul class="simple">
<li>Debug the various chips present on the device.</li>
<li>Set breakpoints and analyse registers and stack at a given time</li>
<li>Analyse flashes located on the device</li>
<li>Program and interact with the flashes</li>
<li>Dump firmware and other sensitive information.</li>
</ul>
</div>
<div class="section" id="installing-software-for-jtag-debugging">
<h3>Installing software for JTAG debugging<a class="headerlink" href="#installing-software-for-jtag-debugging" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>OpenOCD - apt-get install openocd</li>
<li>GDB-Multiarch - apt-get install gdb-multiarch</li>
</ul>
<p>Hardware for JTAG Debugging</p>
<ul class="simple">
<li>Bus Pirate or Segger J-Link?</li>
</ul>
<p>Use OpenOCD to connect via Bus Pirate/ Segger J-link or Attify Badge to connect?</p>
<p>–&gt; Writing Data/ Firmware to Device?</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>flash banks
flash write_image erase firmware.bin 0x08000000
</pre></div>
</div>
<p>Dumping data/ firmware from the device</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>flash banks
dump_image dump.bin starting_point (0x08000000), size(0x0001000)
</pre></div>
</div>
<p>Reading data from device</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>mdw
mdw 0x00 0x20
</pre></div>
</div>
<p>mdw followed by the address and the number of blocks to read.</p>
</div>
<div class="section" id="debugging-over-jtag-with-gdb">
<h3>Debugging over JTAG with GDB<a class="headerlink" href="#debugging-over-jtag-with-gdb" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="firmware-reverse-engineering-and-exploitation">
<h2>Firmware Reverse Engineering and Exploitation<a class="headerlink" href="#firmware-reverse-engineering-and-exploitation" title="Permalink to this headline">¶</a></h2>
<p>Firmware is a piece of code residing on the Non-Volatile section of the device, allowing and enabling the device to perform different tasks required for functioning of the device. It consists of various
components such as kernel, bootloader, file system and additional resources.</p>
<p>File system in Embedded or IoT device firmware can be of different types, depending on the manufacturer’s requirements and the device functionality.</p>
<p>Common file systems include
* Squashfs
* Cramfs
* JFFS2
* YAFFS2
* ext2</p>
<p>Common compression in IoT devices</p>
<ul class="simple">
<li>LZMA</li>
<li>Gzip</li>
<li>Zip</li>
<li>Zlib</li>
<li>ARJ</li>
</ul>
<p>Depending on what file system type and compression type a device is using, the set of tools we will use to extract it will be different.</p>
</div>
<div class="section" id="how-to-get-firmware-binary">
<h2>How to get Firmware Binary<a class="headerlink" href="#how-to-get-firmware-binary" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Getting it online : Check manufactures website, Support page or downloads section of their website or various community support, discussion forums for the device might include the link for the firmware.</li>
<li>Extracting from the device : If we have physical access to the device, we can use various hardware exploitation techniques to dump the firmware from the device flash chip and run additional analysis.</li>
<li>Sniffing OTA ?</li>
<li>Reversing applications?</li>
</ol>
<p>unsquashfs?</p>
<p>binwalk?</p>
<p>Binwalk also allows to do entropy analysis. Entropy analysis - A line with a bit of variation in the middle indicates that data is simply compressed and not encrypted, whereas completely flat line indicates that the data is encrypted.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>binwalk E image.bin
</pre></div>
</div>
</div>
<div class="section" id="firmware-internals">
<h2>Firmware Internals<a class="headerlink" href="#firmware-internals" title="Permalink to this headline">¶</a></h2>
<p>Firmware may contain</p>
<ol class="arabic simple">
<li>Bootloader : Responsible for initializing of various critical hardware components and allocating the required resources.</li>
<li>Kernel : intermediary layer between hardware and the software.</li>
<li>File System : is where all the individual files are stored necessary for the embedded device runtime. Includes components such as web-servers and network services.</li>
</ol>
<p>Typical Embedded device boot ups</p>
<ol class="arabic simple">
<li>Bootloader initiates required hardware and system components for bootup.</li>
<li>Bootloader is passed in the physical address of the kernel as well as the loading up of the device tree.</li>
<li>Kernel is loaded from the above address which then initiates all the required processes and aditional services for the embedded device to operate.</li>
<li>Bootloader dies as kernel gets loaded.</li>
<li>Root file system is mounted</li>
<li>As root file system is mounted, a Linux Kernel spawns a program called init.</li>
</ol>
<div class="section" id="hardcoded-secrets">
<h3>Hardcoded Secrets<a class="headerlink" href="#hardcoded-secrets" title="Permalink to this headline">¶</a></h3>
<p>1. Hardcoded credentials
2 .Backdoor access
3. Sensitive URLs
4. Access tokens
5. API and Encryption keys
6. Encryption algorithms
7. Local pathnames
8. Environment details
9. Authentication and Authorization mechanisms.</p>
</div>
</div>
<div class="section" id="encrypted-firmware">
<h2>Encrypted Firmware?<a class="headerlink" href="#encrypted-firmware" title="Permalink to this headline">¶</a></h2>
<p>Firmware might be encrypted with XOR encryption or even AES encryption?</p>
<p>XOR Encryption - Simply perform a hexdump and see if there are any recurring strings, which is a good indication of usage of XOR encryption. Recurring pattern may be the key. Use decryptxor.py and decrypt the encrypted firmware.</p>
<div class="section" id="emulating-a-firmware-binary">
<h3>Emulating a Firmware Binary<a class="headerlink" href="#emulating-a-firmware-binary" title="Permalink to this headline">¶</a></h3>
<p>There are different platforms such as ARM, MIPS, PowerPC etc.</p>
<p>We can utilize Qemu to emulate the binaries on specific platforms.</p>
<p>To emulate entire firmware, we have to solve specific challenges,</p>
<ul class="simple">
<li>The firmware is meant to run on another architecture.</li>
<li>The firmware during bootup might require configurations and additional information from NVRAM.</li>
<li>The firmware might be dependent on physical hardware components to run.</li>
</ul>
<p>To solve the second NVRAM challenge, we can setup a interceptor which listens to all the calls being made by firmware to NVRAM and return our custom values.</p>
<p>We can use Firmware Analysis Toolkit (FAT) which is a script build on top of Firmadyne - a tool for emulating firmware.</p>
</div>
<div class="section" id="backdooring-a-firmware">
<h3>Backdooring a Firmware<a class="headerlink" href="#backdooring-a-firmware" title="Permalink to this headline">¶</a></h3>
<p>Backdooring a firmware is one of the security issues which a firmware faces if the device has no secure integrity checks and signature validation. We can extract the filesystem from a firmware and then modify the firmware
by adding our own backdoor. The modified firmware can be flashed to the real IoT device, which would then give us backdoored access to the device.</p>
<p>Instead of binwalk, we would use <a class="reference external" href="https://github.com/brianpow/firmware-mod-kit.git">Firmware Mod Kit</a></p>
<p>We have two tasks
* Creating a backdoor and compiling it to run on specific platform (MIPS etc.)
* Modifying entries and placing the backdoor in a location so that it could be started automatically at bootup.</p>
<p>We can use backdoor by OsandaMalith.</p>
<p>We can use BuildRoot to compile programs for a different target architecture that what we are on.</p>
</div>
<div class="section" id="running-automated-firmware-scanning-tools">
<h3>Running Automated firmware scanning tools<a class="headerlink" href="#running-automated-firmware-scanning-tools" title="Permalink to this headline">¶</a></h3>
<p>We can use firmwalker by Craig Smith . Inside the data folder, it contains the entries which firmwalker looks for.</p>
</div>
<div class="section" id="firmware-diffing">
<h3>Firmware Diffing<a class="headerlink" href="#firmware-diffing" title="Permalink to this headline">¶</a></h3>
<p>Diffing can help to understand the various security issues which might have existed in the previous version of the firmware, even if they are not publicily informed.</p>
<p>Kdiff3 or meld and other tools can be used.</p>
</div>
</div>
<div class="section" id="software-defined-radio">
<h2>Software Defined Radio<a class="headerlink" href="#software-defined-radio" title="Permalink to this headline">¶</a></h2>
<p>Software defined radio allows to implement radio processing functionalities which otherwise would need hardware implementatiion to be performed with the use of sofware.</p>
<div class="section" id="setting-up-the-lab">
<h3>Setting up the lab<a class="headerlink" href="#setting-up-the-lab" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>GNURadio</li>
<li>GQRX</li>
<li>Rtl-sdr utilities</li>
<li>HackRF tools</li>
</ul>
<p>We would need hardware too, cheapest RTL-SDR or HackRF,</p>
<p>Limitation of RTL-SDR is it will only allow you to sniff and look at various frequencies and not actually transmit your own data.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>apt-get install gqrx, gnuradio, rtl-sdr, hackrf
</pre></div>
</div>
<ul class="simple">
<li>Data which needs to be transmitted from the Wi-Fi router is being modulated with the carrier signal of 2.4 GHz. This data is passed through the air (transmitting medium) which is being recieved on the other end. Once it is recived,
it is decoded and the final data is obtained from the signal. The modulation process is essential for noise reduction, multiplexing, working with various bandwidth and frequencies, cable properties. etc.</li>
</ul>
<dl class="docutils">
<dt>In modulation, the baseband signal, considered as main information source is carried by higher frequency wave called the carrier signal. Based on the properties of the carrier signal and the type of modulation being used,</dt>
<dd>the properties of the final signal, which travels throught the air changes.</dd>
</dl>
<p>Modulation can be</p>
<ul class="simple">
<li>Analog Modulation : Amplitude, Frequency, SSB and DSB Modulation</li>
<li>Digital Modulation : FSK, PSK and QAM.</li>
</ul>
<p>Can also be divided based on component being modulated</p>
<ul class="simple">
<li>Amplitude Modulation</li>
<li>Frequency Modulation</li>
<li>Phase Modulation</li>
</ul>
<p>Common Terminologies</p>
<ul class="simple">
<li>Transmitter</li>
<li>ADC</li>
<li>Sample Rate</li>
<li>FFT</li>
<li>Bandwidth</li>
<li>Wavelength</li>
<li>Frequency</li>
<li>Antenna</li>
<li>Gain</li>
<li>Filters ( Low Pass, High Pass, Band Pass )</li>
</ul>
<p>Working with GNURadio</p>
<ul class="simple">
<li>Signal Source (Found under Waveform Generator )</li>
<li>Sink?</li>
<li>WX GUI FFT Sikn</li>
</ul>
<p>We can use GQRX to identify and confirm the frequency spectrum of the devices.</p>
<p>Once launched, click devices RTL-SDR</p>
<p>Once, we have confirmed the frequency, we can use utility provided with RTL_SDR ; rtl_433 to analyse the data.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>rtl_433 -f 43392000 (Exact frequency)
</pre></div>
</div>
<p>Now, we can use HackRF to transmit the same packets?</p>
<p>RC-Switch? Ardunio? We can recieve the data sent by ardunio, change that and resend that?</p>
<p>Using GNURadio to decode data?</p>
<p>RTL-SDR Source? Complex to Mag^2 ; Wave file Sink?</p>
<p>If might happen that data is sent by shorter pulses (representing 0) and longer pulses (representing 1)? On-Off Keying (OOK) form of Amplitude-Shift-Keying?</p>
</div>
<div class="section" id="hackrf">
<h3>HackRF<a class="headerlink" href="#hackrf" title="Permalink to this headline">¶</a></h3>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>hackrf_info
hackrf_transfer? - to store the packets captures in a file, later used to replay? -s sample rate, -r specify read file, -f frequency to work with.
</pre></div>
</div>
</div>
</div>
<div class="section" id="zigbee">
<h2>ZigBee<a class="headerlink" href="#zigbee" title="Permalink to this headline">¶</a></h2>
<p>Wireless communication networking standard used for low-power devices.
ZigBee allows devices to communicate using mesh network topology, which enables it to be used both for small and large networks. ZigBee is based on 802.15.4 MAC and PHY layer and have
basic message handling, congestion control</p>
<div class="section" id="understading-zigbee-communication">
<h3>Understading ZigBee Communication<a class="headerlink" href="#understading-zigbee-communication" title="Permalink to this headline">¶</a></h3>
<p>ZigBee network may have various kind of devices</p>
<ul class="simple">
<li>Coordinator : single device in the network responsible for number of actions such as selecting the correct channel, creating a network, forming security settings, handling authentication or even acting as router.</li>
<li>Router : which provides routing services to the various network devices</li>
<li>End devices : perform operations such as reading the temperature or performing actions such as turning on the lights.</li>
</ul>
<p>Total number of channels in Zigbee is 16, we first need to figure out which channel device is operating?</p>
<p>Hardware for Zigbee</p>
<ul class="simple">
<li>Assuming, we have a setup running Zigbee</li>
</ul>
<p>Hardware for exploitation?</p>
<p>KillerBee? tool supports hardware devices such as Atmel RzRaven USB Stick, API Mote, MoteIV Tmote Sky, TelosB mote and Sewino Sniffer.</p>
<p>killerBee/Tools</p>
<p>zbid?
* zbstumbler
* zbdump?
* zbwireshark?</p>
</div>
</div>
<div class="section" id="ble">
<h2>BLE<a class="headerlink" href="#ble" title="Permalink to this headline">¶</a></h2>
<p>GATT
ATT
GAP</p>
<p>BLE provides four different ways to handle pair?</p>
<ul class="simple">
<li>JustWorks</li>
<li>Numeric Comparison</li>
<li>Passkey</li>
<li>Out of Band</li>
</ul>
<div class="section" id="hardware">
<h3>Hardware<a class="headerlink" href="#hardware" title="Permalink to this headline">¶</a></h3>
<p>Gatttool?
hciconfig?</p>
<p>hcitool lescan?</p>
<p>gatttool -I -b target_device?</p>
<p>We can do primary services discovery and list all the various characteristics of the target device</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>primary
</pre></div>
</div>
<p>and read the characteristics with</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>char-read-hnd 0x000c (char hex value)
</pre></div>
</div>
<p><a class="reference external" href="https://www.bluetooth.com/specifications/gatt/services">GATT Services</a></p>
<p>char-desc we can get a list of all the handles optionally also specifiying the attr and end group handles.</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>char-desc 0x0021 0x0032
</pre></div>
</div>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>char-write-req 0x003a 01
</pre></div>
</div>
</div>
<div class="section" id="sniffing-ble-packets">
<h3>Sniffing BLE Packets<a class="headerlink" href="#sniffing-ble-packets" title="Permalink to this headline">¶</a></h3>
<p>Ubertooth One and Adafruit BLE Sniffer</p>
<div class="highlight-None notranslate"><div class="highlight"><pre><span></span>ubertooth-btle?
</pre></div>
</div>
<p>SCAN_REQ</p>
<p>SCAN_RES</p>
<p>-c</p>
<p>BTLEJuice?</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html">tech.bitvijays.com</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Vijay Kumar.
    </div>
  </body>
</html>